---
id: 'typescript'
order: 10
name: 'Typescript Con De Tuti'
titleList:
  - name: 'Introducci√≥n'
    tagId: 'introducci√≥n'
  - name: '¬øPor Qu√© TypeScript?'
    tagId: 'por-qu√©-typescript'
  - name: 'Conceptos Fundamentales de TypeScript'
    tagId: 'conceptos-fundamentales-de-typescript'
  - name: 'TypeScript en la Pr√°ctica'
    tagId: 'typescript-en-la-pr√°ctica'
  - name: 'Mejores Pr√°cticas y Patrones'
    tagId: 'mejores-pr√°cticas-y-patrones'
  - name: '¬øQu√© es Transpilar?'
    tagId: 'qu√©-es-transpilar'
  - name: 'Entendiendo el Tipado en JavaScript y TypeScript'
    tagId: 'entendiendo-el-tipado-en-javascript-y-typescript'
  - name: 'TypeScript: El Superh√©roe del Desarrollo'
    tagId: 'typescript-el-superh√©roe-del-desarrollo'
  - name: 'Ejemplo Pr√°ctico en TypeScript: El Uso de `any` y la Importancia del Tipado'
    tagId: 'ejemplo-pr√°ctico-en-typescript-el-uso-de-any-y-la-importancia-del-tipado'
  - name: 'Tipos Primitivos en TypeScript'
    tagId: 'tipos-primitivos-en-typescript'
  - name: 'Inferencia de Tipos en TypeScript'
    tagId: 'inferencia-de-tipos-en-typescript'
  - name: 'Clases, Interfaces, Enums y Const: ¬øC√≥mo se Utilizan para Tipar en TypeScript?'
    tagId: 'clases-interfaces-enums-y-const-c√≥mo-se-utilizan-para-tipar-en-typescript'
  - name: 'Type vs Interface en TypeScript: Cu√°ndo y C√≥mo Usarlos'
    tagId: 'type-vs-interface-en-typescript-cu√°ndo-y-c√≥mo-usarlos'
  - name: 'El Concepto de Shape en TypeScript'
    tagId: 'el-concepto-de-shape-en-typescript'
  - name: 'Entendiendo union e intersecci√≥n en TypeScript'
    tagId: 'entendiendo-union-e-intersecci√≥n-en-typescript'
  - name: 'Entendiendo `typeof` en TypeScript'
    tagId: 'entendiendo-typeof-en-typescript'
  - name: 'Explorando `as const` en TypeScript'
    tagId: 'explorando-as-const-en-typescript'
  - name: 'Aventura en TypeScript: Type Assertion y Casteo de Tipos'
    tagId: 'aventura-en-typescript-type-assertion-y-casteo-de-tipos'
  - name: 'Functional Overloading en TypeScript: ¬°Pura Magia!'
    tagId: 'functional-overloading-en-typescript-pura-magia'
  - name: 'Utilitarios de TypeScript: Helpers Esenciales'
    tagId: 'utilitarios-de-typescript-helpers-esenciales'
  - name: 'Generics en TypeScript'
    tagId: 'generics-en-typescript'
  - name: 'La Magia de los Enums'
    tagId: 'la-magia-de-los-enums'
---

# Typescript Con De Tuti


## Introducci√≥n

¬°Hola a todos! Aqu√≠ Gentleman al teclado, tray√©ndoles un an√°lisis pormenorizado
sobre TypeScript y c√≥mo este lenguaje puede revolucionar la forma en que
trabajamos en equipos de desarrollo. Este libro es una expansi√≥n de un v√≠deo que
sub√≠ a YouTube, donde hablamos de las bases de TypeScript, las ventajas y c√≥mo
puede ayudar en un equipo. Vamos a sumergirnos no solo en el contenido del
v√≠deo, sino que ampliaremos con ejemplos pr√°cticos, c√≥digo y reflexiones clave
para que ustedes, mis queridos desarrolladores, puedan llevar su c√≥digo a un
nivel superior.

## ¬øPor Qu√© TypeScript?

### ¬øQu√© es TypeScript?

TypeScript es un "superset" de JavaScript, lo que significa que tiene todo lo
que JavaScript ofrece, pero a√±ade m√°s funcionalidades que son especialmente
√∫tiles en proyectos grandes o en equipos. Como mencion√© en el v√≠deo, si
JavaScript es bueno, TypeScript es JavaScript con esteroides.

```typescript
// Ejemplo b√°sico de TypeScript
let mensaje: string = "¬°Hola, TypeScript!";
console.log(mensaje);
```

### Ventajas de Usar TypeScript en Equipos

1. **Seguridad de Tipos**: Reduce los errores comunes en JavaScript permitiendo
   especificar tipos de variables.
2. **Mantenibilidad**: El c√≥digo es m√°s f√°cil de entender y mantener.
3. **Refactorizaci√≥n**: Segura y f√°cil de realizar gracias al sistema de tipos.

## Conceptos Fundamentales de TypeScript

### Variables y Tipos

Uno de los pilares de TypeScript es su capacidad de tipado. Esto evita muchos
errores comunes en JavaScript.

```typescript
// Ejemplo de tipado en TypeScript
let esActivo: boolean = true;
let cantidad: number = 123;
```

### Interfaces y Clases

TypeScript permite definir interfaces y clases, lo que facilita la
implementaci√≥n de patrones de dise√±o avanzados y la organizaci√≥n del c√≥digo.

```typescript
interface Usuario {
  nombre: string;
  edad: number;
}

class Empleado implements Usuario {
  constructor(
    public nombre: string,
    public edad: number,
  ) {}
}
```

## TypeScript en la Pr√°ctica

### An√°lisis de Casos Pr√°cticos

Vamos a analizar el segmento del v√≠deo donde discutimos la mutabilidad de las
variables y c√≥mo TypeScript puede ayudar a controlarla.

```typescript
// Ejemplo de inmutabilidad en TypeScript
let x: number = 10;
// x = "Cambio de tipo"; // Esto generar√° un error en TypeScript.
```

### Creando M√©todos Efectivos

Discutimos tambi√©n c√≥mo la falta de claridad en los tipos puede llevar a errores
en m√©todos que parecen simples.

```typescript
function suma(a: number, b: number): number {
  return a + b;
}
```

## Mejores Pr√°cticas y Patrones

### Trabajando con Equipos

- **Claridad**: Usa tipos siempre.
- **Documentaci√≥n**: Aprovecha las caracter√≠sticas de TypeScript para documentar
  el c√≥digo.
- **Revisi√≥n de C√≥digo**: Fomenta las revisiones de c√≥digo que se centren en la
  mejora del tipado.

### Herramientas y Extensiones

Hablaremos de herramientas que pueden integrarse con TypeScript para mejorar a√∫n
m√°s el flujo de trabajo, como linters, formateadores de c√≥digo, y m√°s.


## ¬øQu√© es Transpilar?

Transpilar, en el mundo de la programaci√≥n, es el proceso de convertir c√≥digo
escrito en un lenguaje (o versi√≥n de un lenguaje) a otro lenguaje (o versi√≥n de
ese lenguaje). En nuestro caso, a menudo hablamos de convertir TypeScript a
JavaScript. B√°sicamente, transpilar es como traducir.

### ¬øPor Qu√© Necesitamos Transpilar?

TypeScript es incre√≠ble porque nos da superpoderes: tipos, interfaces, y un
mont√≥n de ayudas para evitar errores. Pero los navegadores y Node.js no
entienden TypeScript, ellos solo hablan JavaScript. Entonces, necesitamos un
traductor, y ese traductor es el compilador de TypeScript (tsc).

### Ejemplo Pr√°ctico

Vamos a ver esto en acci√≥n con un ejemplo sencillo. Imaginemos que tenemos un
archivo TypeScript `script.ts` con el siguiente c√≥digo:

```typescript
// script.ts
let mensaje: string = "Hola, mundo";
console.log(mensaje);
```

Este archivo contiene una variable `mensaje` de tipo string y un `console.log`
para mostrarla. Ahora, para que nuestro navegador entienda este c√≥digo,
necesitamos transpilarlo a JavaScript. Esto lo hacemos con el comando `tsc`
(TypeScript Compiler):

```bash
tsc script.ts
```

Despu√©s de ejecutar este comando, obtenemos un archivo `script.js` con el
siguiente contenido:

```javascript
// script.js
var mensaje = "Hola, mundo";
console.log(mensaje);
```

Como pod√©s ver, el compilador de TypeScript ha convertido (o "transpilado") el
c√≥digo TypeScript a JavaScript.

### Un Poco M√°s de Magia: Configuraci√≥n del Compilador

Podemos hacer mucho m√°s con la configuraci√≥n de nuestro compilador TypeScript.
Por ejemplo, podemos definir c√≥mo queremos que se comporte el proceso de
transpilar mediante un archivo `tsconfig.json`. Aqu√≠ te dejo un ejemplo b√°sico:

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "es6", // Indica a qu√© versi√≥n de JavaScript queremos transpilar
    "outDir": "./dist", // Carpeta donde se guardar√°n los archivos transpilados
    "strict": true // Activa todas las comprobaciones estrictas
  },
  "include": ["src/**/*.ts"], // Archivos a incluir en la transpilation
  "exclude": ["node_modules"] // Archivos o carpetas a excluir
}
```

### Haciendo Magia con `tsc --watch`

Si quer√©s llevar tu flujo de trabajo al siguiente nivel, pod√©s usar el comando
`tsc --watch`, que va a estar atento a cualquier cambio en tus archivos
TypeScript y autom√°ticamente los va a transpilar a JavaScript. Es como tener un
asistente personal que siempre est√° atento para ayudarte.

```bash
tsc --watch
```

### En Resumen

Transpilar es un proceso esencial que nos permite escribir en lenguajes modernos
y con mejores caracter√≠sticas, y luego convertir ese c√≥digo a un lenguaje que
los navegadores y Node.js pueden entender. Es como tener un traductor que
convierte nuestras palabras en algo que todo el mundo puede entender.

As√≠ que la pr√≥xima vez que escuches "transpilar", ya sab√©s que no es m√°s que un
proceso de traducci√≥n, asegurando que nuestras genialidades en TypeScript
lleguen intactas y claras a cualquier entorno JavaScript.


## Entendiendo el Tipado en JavaScript y TypeScript

### JavaScript: Un Lenguaje con Tipado Din√°mico

Aunque a simple vista no lo parezca, JavaScript s√≠ cuenta con un sistema de
tipos, pero es din√°mico. Esto significa que el tipo de una variable puede
cambiar a lo largo de la ejecuci√≥n del programa, lo que introduce flexibilidad
pero tambi√©n cierta propensi√≥n a errores dif√≠ciles de rastrear. Aqu√≠ es donde
JavaScript muestra tanto su flexibilidad como sus limitaciones, ya que esta
caracter√≠stica puede llevar a confusiones en proyectos grandes o cuando se
trabaja en equipo.

El motor V8 de JavaScript, que es el que utilizan la mayor√≠a de los navegadores
modernos como Chrome y Node.js, maneja el tipado din√°mico de una manera muy
particular. Cuando se define una variable o un m√©todo, V8 asigna un tipo inicial
basado en el valor asignado. Esta informaci√≥n se guarda en un buffer de memoria.

```javascript
// Ejemplo de tipado din√°mico en JavaScript
let valor = "Hola"; // Inicialmente es una cadena
valor = 100; // Ahora es un n√∫mero
```

En este ejemplo, `valor` cambia de un string a un n√∫mero. ¬°Es como si tu perro
de repente decidiera ser gato! Esto, aunque √∫til a veces, puede traer problemas.

Cuando el tipo de una variable cambia, V8 debe reestructurar la forma en que
almacena esta variable en memoria. Esto implica recalcular y reasignar la
memoria para la nueva forma del dato, lo cual puede ser costoso en t√©rminos de
rendimiento.

```javascript
let a = 1; // 'a' es un n√∫mero
a = "uno"; // 'a' ahora es un string
```

El motor V8 detecta el cambio de tipo y ajusta la memoria y las referencias
internas para adaptarse al nuevo tipo. Este proceso puede ralentizar la
ejecuci√≥n si ocurre con frecuencia.

### TypeScript: Estabilidad y Seguridad a Trav√©s del Tipado Est√°tico

En contraste, TypeScript introduce un sistema de tipado est√°tico, que obliga a
definir el tipo de dato de las variables y funciones desde el comienzo. Esto
ayuda a evitar muchos errores comunes en JavaScript al hacer que el c√≥digo sea
m√°s predecible y m√°s f√°cil de debuggear. Al utilizar TypeScript, se puede tener
un control mucho m√°s estricto sobre c√≥mo se manejan los datos en las
aplicaciones, lo que se traduce en un c√≥digo m√°s robusto y seguro.

```typescript
let valor: number = 100;
// valor = "Hola"; // Esto causar√° un error en TypeScript
```

¬°Y listo! Ahora `valor` no puede cambiar de tipo y te aseguras que siempre ser√°
un n√∫mero. Como tener un perro que siempre ser√° perro.

## TypeScript: El Superh√©roe del Desarrollo

Primero, imaginemos que TypeScript es un superh√©roe. Su misi√≥n: salvarnos de los
errores y las pesadillas del c√≥digo JavaScript. Pero, como todo buen superh√©roe,
tiene sus l√≠mites y √°reas de operaci√≥n. En este caso, TypeScript solo usa sus
superpoderes durante el desarrollo.

### ¬øQu√© Hace TypeScript?

TypeScript, como dijimos anteriormente, es JavaScript con esteroides. Te permite
agregar tipos a tus variables y funciones, lo que ayuda a evitar errores
comunes. Pero aqu√≠ viene el truco: cuando tu aplicaci√≥n se ejecuta en el
navegador o en Node.js, todo ese c√≥digo de TypeScript se ha transformado (o
transpilado) en JavaScript. Es como si nuestro superh√©roe se quitara el traje y
se pusiera un uniforme com√∫n y corriente.

### Linters: Los Compa√±eros de Batalla

Ahora, hablemos de los linters. Son como los compa√±eros de equipo de nuestro
superh√©roe. Los linters, como ESLint, trabajan codo a codo con TypeScript para
mantener tu c√≥digo limpio y libre de errores. Mientras que TypeScript se enfoca
en los tipos y la estructura del c√≥digo, los linters se ocupan de las reglas de
estilo y buenas pr√°cticas.

### Ejemplo Pr√°ctico

Vamos a ver un ejemplo para que esto quede m√°s claro. Supongamos que estamos
trabajando en una aplicaci√≥n s√∫per cool:

```typescript
// TypeScript
function saludar(nombre: string): string {
  return `Hola, ${nombre}`;
}

const saludo = saludar("Gentleman");
console.log(saludo);
```

Ac√° tenemos una funci√≥n `saludar` que toma un `nombre` de tipo string y devuelve
un saludo. TypeScript nos asegura que siempre pasemos un string a esta funci√≥n.
Pero, cuando llega el momento de la verdad, esto es lo que se ejecuta en tu
navegador:

```javascript
// JavaScript transpilado
function saludar(nombre) {
  return "Hola, " + nombre;
}

var saludo = saludar("Gentleman");
console.log(saludo);
```

¬°Voil√°! Todo el c√≥digo TypeScript se ha transformado en JavaScript.

### Integraci√≥n con ESLint

Ahora, sumemos a nuestro linter al equipo. Imagina que tenemos una regla que
dice que siempre debemos usar comillas simples. As√≠ se ve el archivo
`.eslintrc.json`:

```json
{
  "rules": {
    "quotes": ["error", "single"]
  }
}
```

Si alguien se pone rebelde y usa comillas dobles en lugar de simples, ESLint nos
va a tirar de las orejas y nos va a recordar seguir las reglas:

```typescript
// C√≥digo incorrecto seg√∫n ESLint
function saludar(nombre: string): string {
  return "Hola, " + nombre; // ESLint nos va a avisar de este error
}
```

Con ESLint integrado, nuestro c√≥digo va a mantenerse limpio y consistente,
haciendo equipo con TypeScript para asegurarnos de que todo est√© en orden.

### En Resumen

TypeScript es nuestro superh√©roe durante el desarrollo, ayud√°ndonos a escribir
c√≥digo m√°s seguro y predecible. Pero una vez que todo est√° listo para la acci√≥n,
se transforma en JavaScript. Y con los linters como compa√±eros de batalla,
mantenemos nuestro c√≥digo en la l√≠nea.

As√≠ que, la pr√≥xima vez que alguien te diga que TypeScript "solo sirve durante
el desarrollo", sabr√°s que, aunque es cierto, es precisamente ah√≠ donde marca la
diferencia.


## Ejemplo Pr√°ctico en TypeScript: El Uso de `any` y la Importancia del Tipado

Vamos a ver por qu√©, aunque TypeScript nos da herramientas
poderosas, usarlas incorrectamente puede llevarnos a caer en los mismos
problemas que podr√≠amos tener en JavaScript. ¬°Prep√°rense para un peque√±o desaf√≠o
mental!

**Paso 1: Declarar una variable con un tipo espec√≠fico**

Vamos a comenzar con algo simple. En TypeScript, podemos especificar el tipo de
una variable para asegurarnos de que siempre contenga el tipo correcto de valor.
Miren este ejemplo:

```typescript
let numero: number = 5;
```

Ahora, si intentamos asignar un valor de un tipo diferente, como un `string`,
TypeScript nos mostrar√° un error. Esto es genial porque previene errores en
tiempo de compilaci√≥n. Vamos a ver:

```typescript
numero = "esto deber√≠a fallar"; // Error: Type 'string' is not assignable to type 'number'.
```

**Paso 2: Uso del tipo `any`**

El tipo `any` en TypeScript nos permite asignar cualquier tipo de valor a una
variable, similar a lo que ocurre por defecto en JavaScript. Veamos:

```typescript
let variableFlexible: any = 5;
variableFlexible = "puedo ser un string tambi√©n";
variableFlexible = true; // ¬°Y ahora un booleano!
```

Con `any`, no hay errores de compilaci√≥n, independientemente del tipo de dato
que asignemos. Esto nos da mucha flexibilidad, pero tambi√©n elimina las
garant√≠as de seguridad de tipo que TypeScript ofrece.

**Pregunta provocativa**

Ahora, aqu√≠ viene la pregunta clave: Si estamos usando `any`, ¬øte parece que
est√° bien? Si piensan que no... entonces no te gusta Javascript ! ya que ser√≠a
lo mismo que usar 'any' en todas nuestras variables.

¬°Exacto! La mayor√≠a dir√° que no es una buena pr√°ctica usar `any`, ya que
perdemos todos los beneficios del tipado est√°tico que TypeScript ofrece. Es como
si volvi√©ramos a JavaScript, donde podemos cometer f√°cilmente errores de tipo.

Usar `any` nos lleva de vuelta a la flexibilidad (y los peligros) de JavaScript.
Si bien `any` puede ser √∫til en situaciones donde necesitamos una soluci√≥n
temporal o cuando trabajamos con bibliotecas de terceros para las cuales no
tenemos tipos, deber√≠amos evitarlo en nuestro c√≥digo principal. En TypeScript,
la meta es aprovechar el sistema de tipos para escribir c√≥digo m√°s seguro y
mantenible.


## Tipos Primitivos en TypeScript

TypeScript enriquece el conjunto de tipos primitivos de JavaScript,
proporcionando un control m√°s robusto y opciones para la declaraci√≥n de
variables. Aqu√≠ est√°n los principales tipos primitivos:

1. **Boolean**: Valor verdadero o falso.

   ```typescript
   let estaActivo: boolean = true;
   ```

2. **Number**: Cualquier n√∫mero, incluyendo decimales, hexadecimales, binarios y
   octales.

   ```typescript
   let cantidad: number = 56;
   let hexadecimal: number = 0xf00d;
   let binario: number = 0b1010;
   let octal: number = 0o744;
   ```

3. **String**: Cadenas de texto.

   ```typescript
   let nombre: string = "Gentleman";
   ```

4. **Array**: Arreglos que pueden ser tipados.

   ```typescript
   let listaDeNumeros: number[] = [1, 2, 3];
   let listaDeStrings: Array<string> = ["uno", "dos", "tres"];
   ```

5. **Tuple**: Permiten expresar un arreglo con n√∫mero fijo y tipos de elementos
   conocidos, pero no necesariamente del mismo tipo.

   ```typescript
   let tupla: [string, number] = ["hola", 10];
   ```

6. **Enum**: Un medio para dar nombres m√°s amigables a conjuntos de valores
   num√©ricos.

   ```typescript
   enum Color {
     Rojo,
     Verde,
     Azul,
   }
   let c: Color = Color.Verde;
   ```

7. **Any**: Para valores que pueden cambiar de tipo en el tiempo, es una forma
   de decirle a TypeScript que maneje la variable como en JavaScript puro.

   ```typescript
   let noEstoySeguro: any = 4;
   noEstoySeguro = "quiz√°s sea una cadena";
   noEstoySeguro = false; // ahora es un booleano
   ```

8. **Void**: Ausencia de tener cualquier tipo, usado com√∫nmente como tipo de
   retorno en funciones que no retornan nada.

   ```typescript
   function advertirUsuario(): void {
     console.log("Este es un aviso!");
   }
   ```

9. **Null y Undefined**: Son subtipos de todos los otros tipos.

   ```typescript
   let u: undefined = undefined;
   let n: null = null;
   ```

## Inferencia de Tipos en TypeScript

TypeScript es inteligente cuando se trata de inferir los tipos de las variables
bas√°ndose en la informaci√≥n disponible, como el valor inicial de las variables.
Sin embargo, esta inferencia puede ser complicada.

```typescript
let mensaje = "Hola, mundo";
// `mensaje` es autom√°ticamente inferido como `string`
```

### Trampas de la Inferencia en TypeScript: Un Ejemplo Pr√°ctico

¬°Hola, comunidad! Hoy vamos a profundizar en un tema fascinante y a veces
complicado de TypeScript: las trampas de la inferencia de tipos, utilizando un
ejemplo pr√°ctico que nos mostrar√° c√≥mo TypeScript maneja la inferencia de tipos
dentro de estructuras de control complejas.

#### Ejemplo Problem√°tico

Consideremos el siguiente c√≥digo TypeScript:

```typescript
const arregloDeValores = [
  {
    numero: 1,
    label: "label1",
  },
  {
    numero: 2,
  },
];

const metodo = (param: typeof arregloDeValores) => {
  const indexArray = [1, 2];

  indexArray.forEach((index) => {
    if (param[index].label) {
      // param[index].label => string | undefined
      console.log(param[index].label); // param[index].label => string | undefined
    }
  });
};
```

En este ejemplo, tenemos un arreglo `arregloDeValores` que contiene objetos con
las propiedades `numero` y `label`. Sin embargo, notar√°n que el segundo objeto
en el arreglo no tiene definida la propiedad `label`. Esto hace que el tipo de
`label` sea inferido como `string | undefined`.

#### Problema de Inferencia

Cuando pasamos `arregloDeValores` a la funci√≥n `metodo` y usamos `forEach` para
iterar sobre un arreglo de √≠ndices, hacemos una comprobaci√≥n en cada iteraci√≥n
para ver si `label` est√° presente. Si bien dentro del bloque `if`, uno podr√≠a
esperar que TypeScript entienda que `label` no es `undefined` debido a la
comprobaci√≥n, la realidad es que TypeScript a√∫n considera que el tipo de
`param[index].label` es `string | undefined` tanto dentro como fuera del `if`.

##### ¬øPor qu√© ocurre esto?

TypeScript no lleva un "estado" del tipo a trav√©s del flujo del c√≥digo de la
misma manera que lo har√≠a en un contexto m√°s simple. Aunque dentro del bloque
`if` ya verificamos que `label` existe, TypeScript no tiene una "memoria" de
esta comprobaci√≥n para futuras referencias en el mismo bloque de c√≥digo. Esto es
especialmente cierto cuando estamos iterando o utilizando estructuras m√°s
complejas como `forEach`, `for`, etc., donde las comprobaciones de tipo no se
"propagan" m√°s all√° del √°mbito inmediato en el que se realizan.

#### Consejo para Manejar la Inferencia en Bloques Iterativos

Para manejar mejor estos casos y asegurar que el c√≥digo sea tipo-seguro sin
depender de la inferencia de TypeScript, podr√≠as considerar las siguientes
pr√°cticas:

1. **Asignaci√≥n a Variables Temporales**: A veces, asignar a una variable
   temporal dentro del bloque puede ayudar.

   ```typescript
   indexArray.forEach((index) => {
     const label = param[index].label;
     if (label) {
       console.log(label); // TypeScript entiende que label es string aqu√≠
     }
   });
   ```

2. **Refinamiento de Tipos con Tipos de Guardia**: Utiliza tipos de guardia para
   refinar los tipos dentro de los bloques iterativos o condicionales.

   ```typescript
   indexArray.forEach((index) => {
     if (typeof param[index].label === "string") {
       console.log(param[index].label); // Ahora es seguro que es un string
     }
   });
   ```

## Clases, Interfaces, Enums y Const: ¬øC√≥mo se Utilizan para Tipar en TypeScript?

Cada uno de estos elementos tiene su propia magia para ayudarnos a escribir
c√≥digo m√°s limpio, escalable y seguro. Vamos a desglosar cada uno y ver c√≥mo y
cu√°ndo utilizarlos. üé©‚ú®

### 1. **Clases**

Las clases en TypeScript no solo son una plantilla para crear objetos, sino que
tambi√©n pueden ser utilizadas como tipos.

```typescript
class Automovil {
  constructor(
    public marca: string,
    public modelo: string,
  ) {}
}

let miAuto: Automovil = new Automovil("Toyota", "Corolla");
```

En el ejemplo, `Automovil` no solo define una clase sino tambi√©n un tipo. Cuando
decimos `let miAuto: Automovil`, estamos utilizando la clase como un tipo,
asegurando que `miAuto` cumpla con la estructura y comportamiento definidos en
la clase `Automovil`.

### 2. **Interfaces**

Las interfaces son potentes en TypeScript por su habilidad de definir contratos
de estructuras para clases, objetos y funciones sin generar JavaScript al
compilar. Son ideales para definir formas de datos y se usan extensamente en la
programaci√≥n orientada a objetos y en la integraci√≥n con bibliotecas.

```typescript
interface Vehiculo {
  marca: string;
  arrancar(): void;
}

class Camion implements Vehiculo {
  constructor(
    public marca: string,
    public capacidadCarga: number,
  ) {}
  arrancar() {
    console.log("El cami√≥n est√° arrancando...");
  }
}
```

Las interfaces no solo permiten tipar objetos y clases, tambi√©n pueden ser
extendidas y combinadas, lo cual es excelente para mantener el c√≥digo organizado
y reutilizable.

### 3. **Enums**

Los enums o enumeraciones permiten definir un conjunto de constantes nombradas.
Son √∫tiles para manejar un conjunto de valores relacionados, proporcionando una
forma de agruparlos bajo un mismo tipo.

```typescript
enum Color {
  Rojo,
  Verde,
  Azul,
}

let colorFavorito: Color = Color.Verde;
```

Utilizar enums mejora la legibilidad del c√≥digo y reduce la posibilidad de
errores al restringir los valores que una variable puede tomar.

### 4. **Const Assertions**

En TypeScript, `const` no solo define una constante a nivel de ejecuci√≥n, sino
que tambi√©n puede ser utilizada para hacer afirmaciones de tipo (type
assertions). Usando `as const`, podemos decirle a TypeScript que trate el tipo
de manera m√°s espec√≠fica y literal.

```typescript
let config = {
  nombre: "Aplicaci√≥n",
  version: 1,
} as const;

// config.nombre = "Otra App"; // Error, porque nombre es una constante.
```

Esto es especialmente √∫til para definir objetos con propiedades que nunca
cambiar√°n sus valores una vez asignados.

## Type vs Interface en TypeScript: Cu√°ndo y C√≥mo Usarlos

Aunque ambos se pueden usar para definir tipos en TypeScript, tienen sus particularidades y casos de uso
ideales. Vamos a desglosar las diferencias y entender cu√°ndo es mejor usar cada
uno. üöÄ

### ¬øQu√© es `interface`?

Una `interface` en TypeScript se utiliza principalmente para describir la forma
que deben tener los objetos. Es una manera de definir contratos dentro de tu
c√≥digo as√≠ como tambi√©n contratos con c√≥digo externo al tuyo.

```typescript
interface Usuario {
  nombre: string;
  edad?: number;
}

function saludar(usuario: Usuario) {
  console.log(`Hola, ${usuario.nombre}`);
}
```

Las interfaces son ideales para la programaci√≥n orientada a objetos en
TypeScript, donde puedes usarlas para asegurar que ciertas clases implementen
m√©todos y propiedades espec√≠ficos.

### Ventajas de usar `interface`:

1. **Extensibilidad**: Las interfaces son extendibles y pueden ser extendidas
   por otras interfaces. Usando `extends`, una interfaz puede heredar de otra,
   lo cual es excelente para mantener grandes bases de c√≥digo bien organizadas.
2. **Fusionado de Declaraciones**: TypeScript permite que las declaraciones de
   `interface` sean fusionadas autom√°ticamente. Si defines la misma interfaz en
   diferentes lugares, TypeScript las combina en una sola interfaz.

### ¬øQu√© es `type`?

El alias de tipo `type` se puede utilizar para crear un tipo personalizado y
puede ser asignado a cualquier tipo de dato, no s√≥lo a objetos. Los `type` son
m√°s vers√°tiles que las interfaces en ciertos aspectos.

```typescript
type Punto = {
  x: number;
  y: number;
};

type D3Punto = Punto & { z: number };
```

### Ventajas de usar `type`:

1. **Tipos Uni√≥n e Intersecci√≥n**: Con `type`, puedes f√°cilmente utilizar tipos
   uni√≥n e intersecci√≥n para combinar tipos existentes de formas complejas y
   √∫tiles.

2. **Tipos Primitivos y Tuplas**: Los `type` pueden ser utilizados para alias de
   tipos primitivos, uniones, intersecciones, y tuplas.

### ¬øCu√°ndo usar `interface` o `type`?

1. **Usa `interface` cuando:**

   - Necesitas definir un 'contrato' para clases o para la forma de objetos.
   - Quieres aprovechar las capacidades de extensi√≥n y fusi√≥n de interfaces.
   - Est√°s creando una librer√≠a de definiciones de tipo o una API que ser√° usada
     en otros proyectos TypeScript.

2. **Usa `type` cuando:**
   - Necesitas usar uniones o intersecciones.
   - Quieres usar tuplas y otros tipos que no pueden ser expresados con una
     `interface`.
   - Prefieres trabajar con tipos m√°s flexibles y no necesitas extender o
     implementarlos desde clases.


## El Concepto de Shape en TypeScript

Ahora vamos a hablar de un concepto fundamental en TypeScript que nos ayuda a
manejar la estructura y el tipo de nuestros objetos: el **shape**. Este concepto
es crucial para entender c√≥mo TypeScript maneja la tipificaci√≥n y c√≥mo podemos
sacarle el m√°ximo provecho a nuestro c√≥digo. As√≠ que, ¬°Con de Tuti! üöÄ

### ¬øQu√© es el Shape?

El concepto de **shape** (o forma) en TypeScript se refiere a la estructura que
debe tener un objeto para ser considerado de un cierto tipo. B√°sicamente, cuando
definimos un tipo o una interfaz, estamos definiendo el shape que cualquier
objeto de ese tipo debe seguir.

```typescript
interface Usuario {
  nombre: string;
  edad: number;
}

let usuario: Usuario = {
  nombre: "Juan",
  edad: 25,
};
```

En este ejemplo, `Usuario` define el shape que el objeto `usuario` debe tener:
debe tener las propiedades `nombre` y `edad` de los tipos `string` y `number`,
respectivamente.

### Inferencia de Tipos y Shape

TypeScript es muy bueno inferiendo tipos basados en los valores que
proporcionamos. Sin embargo, la inferencia de tipos tambi√©n se basa en el shape
de los objetos.

```typescript
let otroUsuario = {
  nombre: "Ana",
  edad: 30,
};
```

Aqu√≠, TypeScript inferir√° que `otroUsuario` tiene el shape
`{ nombre: string; edad: number; }` sin necesidad de que lo especifiquemos
expl√≠citamente.

### Trampas de la Inferencia con Shape

A veces, confiar en la inferencia de tipos puede llevar a situaciones
complicadas, especialmente cuando trabajamos con objetos complejos y arrays.
Vamos a volver a ver un ejemplo de c√≥mo esto puede ser problem√°tico:

```typescript
const arregloDeValores = [
  {
    numero: 1,
    label: "label1",
  },
  {
    numero: 2,
  },
];

const metodo = (param: typeof arregloDeValores) => {
  const indexArray = [1, 2];

  indexArray.forEach((index) => {
    if (param[index].label) {
      console.log(param[index].label);
    }
  });
};
```

En este caso ya antes visto, `param[index].label` sigue siendo
`string | undefined` tanto fuera como dentro del `if`, por m√°s que hemos
comprobado su existencia. ¬øPor qu√© pasa esto? Porque TypeScript no puede
garantizar que el shape se mantendr√° constante a lo largo de la iteraci√≥n sin
almacenar la comprobaci√≥n en una variable.

#### Manejo Correcto del Shape

Para manejar correctamente estas situaciones, es mejor guardar las
comprobaciones en una variable, lo cual le da a TypeScript una pista m√°s clara
sobre el shape:

```typescript
const metodo = (param: typeof arregloDeValores) => {
  const indexArray = [1, 2];

  indexArray.forEach((index) => {
    const item = param[index];
    if (item.label) {
      console.log(item.label);
    }
  });
};
```

Ahora, TypeScript entiende que `item.label` dentro del `if` es un `string` y no
`undefined`.


## Entendiendo union e intersecci√≥n en TypeScript

Vamos a explorar dos operadores fundamentales en TypeScript que nos permiten
manejar tipos de manera flexible y poderosa: `|` (uni√≥n) y `&` (intersecci√≥n).
Estos operadores son clave para definir tipos complejos y manejar diferentes
escenarios en nuestros programas. ¬°Vamos a sumergirnos en ellos!

### Operador | (Uni√≥n)

El operador `|` en TypeScript se utiliza para combinar tipos de manera que un
valor pueda ser de uno de esos tipos. Es decir, si tenemos `TipoA | TipoB`,
estamos diciendo que una variable puede ser de tipo `TipoA` o de tipo `TipoB`.

```typescript
type Resultado = "√©xito" | "error";

let estado: Resultado;

estado = "√©xito"; // v√°lido
estado = "error"; // v√°lido
estado = "otro"; // inv√°lido, TypeScript marcar√° un error
```

En este ejemplo, `estado` puede ser `"√©xito"` o `"error"`, pero no puede ser
otro valor.

#### Combinaci√≥n de Tipos con Propiedades Compartidas

Cuando utilizamos el operador `|` para combinar tipos que comparten algunas
propiedades, estas propiedades se conservan en la uni√≥n solo si son comunes a
todos los tipos incluidos. Veamos un ejemplo para entender mejor este concepto:

```typescript
interface Perro {
  tipo: "perro";
  ladra: boolean;
}

interface Gato {
  tipo: "gato";
  maulla: boolean;
}

type Animal = Perro | Gato;

function procesarAnimal(animal: Animal) {
  // Solo podemos acceder a la propiedad 'tipo' com√∫n a ambos tipos
  console.log(animal.tipo);

  // Esto generar√≠a un error, ya que 'ladra' o 'maulla' dependen del tipo espec√≠fico
  // console.log(animal.ladra); // Error: 'ladra' no existe en el tipo 'Animal'.
  // console.log(animal.maulla); // Error: 'maulla' no existe en el tipo 'Animal'.
}

let miPerro: Perro = { tipo: "perro", ladra: true };
let miGato: Gato = { tipo: "gato", maulla: true };

procesarAnimal(miPerro); // Salida esperada: "perro"
procesarAnimal(miGato); // Salida esperada: "gato"
```

En este ejemplo, `Animal` es una uni√≥n de `Perro` y `Gato`. Aunque ambos tipos
tienen la propiedad `tipo`, las propiedades espec√≠ficas como `ladra` y `maulla`
solo est√°n disponibles cuando se trabaja con un tipo espec√≠fico (`Perro` o
`Gato`), no en el tipo `Animal` como un todo.

### Operador & (Intersecci√≥n)

Por otro lado, el operador `&` en TypeScript se utiliza para crear un tipo que
tenga todas las propiedades de los tipos que estamos combinando. Es decir,
`TipoA & TipoB` significa un tipo que tiene todas las propiedades de `TipoA` y
todas las propiedades de `TipoB`.

```typescript
interface Persona {
  nombre: string;
}

interface Empleado {
  salario: number;
}

type EmpleadoConNombre = Persona & Empleado;

let empleado: EmpleadoConNombre = {
  nombre: "Juan",
  salario: 3000,
};
```

En este caso, `EmpleadoConNombre` es un tipo que tiene tanto `nombre` como
`salario`, combinando las propiedades de `Persona` y `Empleado`.

### Uso de | y & juntos

Podemos combinar `|` y `&` para crear tipos a√∫n m√°s complejos y espec√≠ficos
seg√∫n nuestras necesidades:

```typescript
type Opciones = { modo: "modoA" | "modoB" } & { tama√±o: "peque√±o" | "grande" };

let configuracion: Opciones = {
  modo: "modoA",
  tama√±o: "peque√±o",
};
```

En este ejemplo, `configuracion` debe tener tanto `modo` (que puede ser
`"modoA"` o `"modoB"`) como `tama√±o` (que puede ser `"peque√±o"` o `"grande"`).

### Diferencias Clave

- **`|` (Uni√≥n)**: Se usa para combinar tipos donde un valor puede ser de
  cualquiera de esos tipos.
- **`&` (Intersecci√≥n)**: Se usa para combinar tipos donde un valor debe tener
  todas las propiedades de esos tipos.


## Entendiendo `typeof` en TypeScript

Ahora vamos a ver el uso del operador `typeof` en TypeScript y c√≥mo puede
ayudarnos a manejar tipos complejos de manera m√°s eficiente.

### Concepto de `typeof`

En TypeScript, `typeof` es un operador que nos permite referirnos al tipo de una
variable, propiedad o expresi√≥n en tiempo de compilaci√≥n. Este operador devuelve
el tipo est√°tico de la expresi√≥n a la que se aplica. Es muy √∫til cuando
necesitamos referirnos a un tipo existente en lugar de definirlo expl√≠citamente.

```typescript
let x = 10;
let y: typeof x; // y ser√° del tipo 'number'
```

En el ejemplo anterior, `typeof x` se eval√∫a como el tipo de la variable `x`,
que es `number`. Esto nos permite asignar el tipo de `x` a otra variable `y` sin
tener que especificarlo manualmente.

### Utilizaci√≥n para Tipos Complejos

Una de las mayores ventajas de `typeof` es su capacidad para manejar tipos
complejos de manera m√°s clara y concisa. Por ejemplo, cuando trabajamos con
tipos que son el resultado de uniones o intersecciones complejas, podemos
utilizar `typeof` para capturar esos tipos de manera eficiente.

```typescript
interface Persona {
  nombre: string;
  edad: number;
}

type Empleado = {
  id: number;
  puesto: string;
} & typeof miPersona; // Captura el tipo de 'miPersona'

const miPersona = { nombre: "Juan", edad: 30 };

let empleado: Empleado;

empleado = { id: 1, puesto: "Desarrollador", nombre: "Juan", edad: 30 };
```

En este ejemplo, `typeof miPersona` captura el tipo de `miPersona`, que es
`{ nombre: string; edad: number; }`. Luego, este tipo se combina (`&`) con las
propiedades adicionales de `Empleado`. Esto nos permite definir `Empleado` de
una manera que aprovecha directamente el tipo de `miPersona` sin tener que
repetir su estructura.

### Beneficios de `typeof`

- **Refleja Cambios Autom√°ticamente:** Si modificamos `miPersona`, el tipo de
  `Empleado` se ajustar√° autom√°ticamente para reflejar esos cambios.
- **Evita Duplicaci√≥n de C√≥digo:** No necesitamos definir manualmente la
  estructura de `Persona` dos veces; `typeof` se encarga de mantener la
  consistencia.

- **Mantenimiento Simplificado:** Cuando el tipo de `miPersona` cambia, los usos
  de `typeof` se actualizan autom√°ticamente, reduciendo errores y tiempos de
  mantenimiento.

## Explorando `as const` en TypeScript

Este operador puede ayudarnos a definir valores constantes inmutables, mejorando
la seguridad y precisi√≥n de nuestro c√≥digo. Vamos a ver c√≥mo funciona y c√≥mo
podemos usarlo para sacarle el m√°ximo provecho.

### ¬øQu√© es `as const`?

El operador `as const` le dice a TypeScript que trate el valor de una expresi√≥n
como una constante literal. Esto significa que cada valor se considerar√°
inmutable y su tipo se reducir√° a su forma m√°s espec√≠fica posible. Esto es
particularmente √∫til cuando queremos asegurarnos de que los valores no cambien
en el futuro.

#### Ejemplo B√°sico

Comencemos con un ejemplo simple para ver c√≥mo funciona `as const`:

```typescript
let colores = ["rojo", "verde", "azul"] as const;
```

Sin `as const`, `colores` ser√≠a del tipo `string[]`, lo que permite cualquier
cadena en el array. Pero al usar `as const`, `colores` se convierte en un tipo
literal espec√≠fico: `readonly ["rojo", "verde", "azul"]`. Ahora, TypeScript sabe
que `colores` contiene exactamente esos tres elementos y nada m√°s.

#### Aplicaci√≥n en Objetos

El uso de `as const` no se limita a arrays; tambi√©n puede ser aplicado a
objetos. Esto es especialmente √∫til cuando trabajamos con configuraciones o
datos que no deber√≠an cambiar.

```typescript
const configuracion = {
  modo: "producci√≥n",
  version: 1.2,
  opciones: {
    depuracion: false,
  },
} as const;
```

En este caso, el objeto `configuracion` tiene un tipo inmutable con los valores
exactos que hemos definido. Esto significa que `configuracion.modo` es del tipo
`"producci√≥n"`, `configuracion.version` es del tipo `1.2`, y
`configuracion.opciones.depuracion` es del tipo `false`.

#### Beneficios de `as const`

1. **Inmutabilidad:** Los valores no pueden ser cambiados, lo que previene
   errores accidentales.
2. **Tipos Literales:** Los tipos se reducen a sus formas m√°s espec√≠ficas,
   mejorando la precisi√≥n del tipado.
3. **Seguridad de Tipo:** Garantiza que los valores no se modifiquen en tiempo
   de ejecuci√≥n, proporcionando mayor seguridad en el c√≥digo.

#### Uso en Funciones

Veamos c√≥mo `as const` puede mejorar la precisi√≥n en el contexto de funciones:

```typescript
function obtenerConfiguracion() {
  return {
    modo: "producci√≥n",
    version: 1.2,
    opciones: {
      depuracion: false,
    },
  } as const;
}

const config = obtenerConfiguracion();
// config.modo es "producci√≥n", no string
// config.version es 1.2, no number
// config.opciones.depuracion es false, no boolean
```

Aqu√≠, la funci√≥n `obtenerConfiguracion` devuelve un objeto cuyo tipo es
inmutable gracias a `as const`. Esto asegura que los valores devueltos tengan
los tipos m√°s espec√≠ficos posibles.

## Aventura en TypeScript: Type Assertion y Casteo de Tipos

Vamos a explorar c√≥mo utilizarlos correctamente, los cuidados que debemos tener,
y la diferencia crucial entre `unknown` y `any`. ¬°Vamos a darle!

### ¬øQu√© es Type Assertion?

Type Assertion es una forma de indicarle a TypeScript que trate una variable
como si fuera de un tipo espec√≠fico. Es como decirle al compilador: "Conf√≠a en
m√≠, s√© lo que estoy haciendo". Esto puede ser √∫til en situaciones donde estamos
seguros del tipo de una variable, pero TypeScript no puede inferirlo
correctamente.

Hay dos sintaxis principales para Type Assertion en TypeScript:

1. **Usando el operador `as`:**

   ```typescript
   let valor: any = "Este es un string";
   let longitud: number = (valor as string).length;
   ```

2. **Usando el operador `<type>`:**

   ```typescript
   let valor: any = "Este es un string";
   let longitud: number = (<string>valor).length;
   ```

Ambas sintaxis logran lo mismo, pero `as` es m√°s com√∫nmente utilizada en c√≥digo
moderno de TypeScript, especialmente cuando se trabaja con JSX en React.

## Cuidados con Type Assertion

Type Assertion es poderoso, pero tambi√©n puede ser peligroso si se usa
incorrectamente. Aqu√≠ hay algunas cosas a tener en cuenta:

1. **Confianza en el Tipo:** Aseg√∫rate de que la aserci√≥n sea v√°lida. Si te
   equivocas, puedes introducir errores dif√≠ciles de detectar.

   ```typescript
   let valor: any = "Este es un string";
   let numero: number = valor as number; // ¬°Error en tiempo de ejecuci√≥n!
   ```

2. **Evitar aserciones innecesarias:** No uses Type Assertion si TypeScript
   puede inferir el tipo correctamente.

   ```typescript
   let valor = "Este es un string"; // TypeScript infiere que 'valor' es un string
   let longitud: number = valor.length; // No se necesita Type Assertion
   ```

## Casteo de Tipos en TypeScript

El casteo de tipos es similar a Type Assertion, pero a menudo se refiere a
convertir un tipo a otro en tiempo de ejecuci√≥n, algo m√°s com√∫n en lenguajes
como C# o Java. En TypeScript, el casteo generalmente se logra mediante
funciones de conversi√≥n.

Ejemplo:

```typescript
let valor: any = "123";
let numero: number = Number(valor); // Casteo de string a number
```

Aunque TypeScript es un superset de JavaScript, no agrega caracter√≠sticas de
casteo expl√≠cito, sino que se basa en funciones de conversi√≥n de JavaScript.

## `unknown` vs `any`: Conoce la Diferencia

`any` y `unknown` son dos tipos especiales en TypeScript que permiten trabajar
con valores de cualquier tipo, pero tienen diferencias clave en su uso y
seguridad.

1. **`any`:**

   - Permite que cualquier valor sea asignado a una variable.
   - Desactiva todas las comprobaciones de tipo, lo que puede llevar a errores
     en tiempo de ejecuci√≥n.
   - Debe usarse con moderaci√≥n.

   ```typescript
   let valor: any = "Este es un string";
   valor = 42; // No hay error, pero puede causar problemas en tiempo de ejecuci√≥n
   valor.metodoInexistente(); // No hay error en tiempo de compilaci√≥n, pero fallar√° en tiempo de ejecuci√≥n
   ```

2. **`unknown`:**

   - Tambi√©n permite que cualquier valor sea asignado a una variable.
   - Obliga a realizar comprobaciones de tipo antes de acceder a las propiedades
     o m√©todos, haciendo el c√≥digo m√°s seguro.

   ```typescript
   let valor: unknown = "Este es un string";

   if (typeof valor === "string") {
     console.log(valor.length); // Safe, TypeScript sabe que es un string
   }

   // valor.metodoInexistente(); // Error en tiempo de compilaci√≥n
   ```

## Ejemplo Combinado

Veamos un ejemplo que combine Type Assertion, `any`, y `unknown`:

```typescript
function procesarValor(valor: unknown) {
  if (typeof valor === "string") {
    let longitud = (valor as string).length;
    console.log(`La longitud del string es ${longitud}`);
  } else if (typeof valor === "number") {
    let doble = (valor as number) * 2;
    console.log(`El doble del n√∫mero es ${doble}`);
  } else {
    console.log("El valor no es ni un string ni un n√∫mero");
  }
}

let valorAny: any = "Texto";
procesarValor(valorAny);

valorAny = 100;
procesarValor(valorAny);

valorAny = true;
procesarValor(valorAny); // El valor no es ni un string ni un n√∫mero
```

En este ejemplo, usamos `unknown` para recibir valores de cualquier tipo, luego
verificamos su tipo antes de realizar operaciones espec√≠ficas. Tambi√©n mostramos
c√≥mo `any` puede ser flexible, pero debe manejarse con cuidado para evitar
errores.

## Functional Overloading en TypeScript: ¬°Pura Magia!

Vamos a explorar c√≥mo podemos definir m√∫ltiples
firmas para una funci√≥n y c√≥mo utilizar tipos para que nuestras funciones
cambien su output seg√∫n el tipo de par√°metro de entrada. ¬°Vamos a darle!

### ¬øQu√© es Functional Overloading?

En TypeScript, functional overloading (sobrecarga de funciones) nos permite
definir m√∫ltiples firmas para una funci√≥n, de modo que pueda aceptar diferentes
tipos de argumentos y comportarse de manera distinta seg√∫n el tipo de entrada.

Esto es particularmente √∫til cuando tenemos una funci√≥n que puede operar de
diferentes maneras dependiendo de los par√°metros que reciba.

### Sintaxis B√°sica

La sintaxis b√°sica para definir una sobrecarga de funciones en TypeScript
incluye varias firmas de funci√≥n seguidas de una implementaci√≥n que cubre todos
los casos.

```typescript
function miFuncion(param: string): string;
function miFuncion(param: number): number;
function miFuncion(param: boolean): boolean;

// Implementaci√≥n que cubre todas las sobrecargas
function miFuncion(
  param: string | number | boolean,
): string | number | boolean {
  if (typeof param === "string") {
    return `String recibido: ${param}`;
  } else if (typeof param === "number") {
    return param * 2;
  } else {
    return !param;
  }
}

// Uso de la funci√≥n sobrecargada
console.log(miFuncion("Hola")); // String recibido: Hola
console.log(miFuncion(42)); // 84
console.log(miFuncion(true)); // false
```

En este ejemplo, `miFuncion` puede aceptar un `string`, un `number` o un
`boolean`, y se comportar√° de manera diferente seg√∫n el tipo del argumento.

### Ejemplos Pr√°cticos

1. **Funci√≥n para manipular arrays y strings:**

   ```typescript
   function manipular(data: string): string[];
   function manipular(data: string[]): string;
   function manipular(data: string | string[]): string | string[] {
     if (typeof data === "string") {
       return data.split("");
     } else {
       return data.join("");
     }
   }

   // Uso de la funci√≥n sobrecargada
   console.log(manipular("Hola")); // ['H', 'o', 'l', 'a']
   console.log(manipular(["H", "o", "l", "a"])); // "Hola"
   ```

2. **Funci√≥n para manejar diferentes tipos de entradas y producir diferentes
   salidas:**

   ```typescript
   function calcular(input: number): number;
   function calcular(input: string): string;
   function calcular(input: number | string): number | string {
     if (typeof input === "number") {
       return input * input;
     } else {
       return input.toUpperCase();
     }
   }

   // Uso de la funci√≥n sobrecargada
   console.log(calcular(5)); // 25
   console.log(calcular("hola")); // "HOLA"
   ```

### Consideraciones Importantes

1. **Implementaci√≥n Unificada:** La implementaci√≥n de la funci√≥n debe ser capaz
   de manejar todos los tipos de par√°metros definidos en las firmas de
   sobrecarga.
2. **Retorno Compatible:** El tipo de retorno debe ser compatible con todos los
   tipos definidos en las firmas de sobrecarga.
3. **Uso Apropiado de Type Guards:** Es fundamental usar correctamente los type
   guards (`typeof`, `instanceof`) para asegurar que la implementaci√≥n maneje
   adecuadamente cada tipo.

### Caso con tipos complejos

### Sobrecarga de Funciones con Tipos Complejos

Primero, definimos nuestras interfaces para los tipos complejos `Gato` y
`Perro`, que extienden una interfaz base `Animal`.

```typescript
interface Animal {
  tipo: string;
  sonido(): void;
}

interface Gato extends Animal {
  tipo: "gato";
  raza: string;
}

interface Perro extends Animal {
  tipo: "perro";
  color: string;
}
```

Luego, definimos las declaraciones de sobrecarga de la funci√≥n `procesarAnimal`
para especificar los tipos de entrada y los tipos de salida.

```typescript
function procesarAnimal(animal: Gato): string;
function procesarAnimal(animal: Perro): number;
```

A continuaci√≥n, implementamos la funci√≥n `procesarAnimal` utilizando la
sobrecarga de funciones. Dependiendo de si el par√°metro es un `Gato` o un
`Perro`, la funci√≥n devolver√° un `string` o un `number`, respectivamente.

```typescript
function procesarAnimal(animal: Gato | Perro): string | number {
  if ("raza" in animal) {
    // El objeto es un gato
    console.log(`Es un gato de raza ${animal.raza}`);
    animal.sonido();
    return animal.raza;
  } else {
    // El objeto es un perro
    console.log(`Es un perro de color ${animal.color}`);
    animal.sonido();
    return animal.color.length;
  }
}
```

### Implementaci√≥n de los Tipos

Creamos instancias de `Gato` y `Perro` y utilizamos la funci√≥n `procesarAnimal`
para procesar estos objetos. Dependiendo del tipo de objeto, la funci√≥n
devolver√° un `string` o un `number`.

```typescript
const miGato: Gato = {
  tipo: "gato",
  raza: "Siam√©s",
  sonido: () => console.log("Miau"),
};
const miPerro: Perro = {
  tipo: "perro",
  color: "Negro",
  sonido: () => console.log("Guau"),
};

const resultadoGato = procesarAnimal(miGato); // Output: Es un gato de raza Siam√©s \n Miau
const resultadoPerro = procesarAnimal(miPerro); // Output: Es un perro de color Negro \n Guau

console.log(resultadoGato); // Output: Siam√©s
console.log(resultadoPerro); // Output: 5
```

En este ejemplo, `procesarAnimal(miGato)` devolver√° la raza del gato como un
`string`, mientras que `procesarAnimal(miPerro)` devolver√° la longitud del color
del perro como un `number`.

### Ejemplo Adicional: Sobrecarga con Verificaci√≥n de Propiedades

Ahora, veamos otro ejemplo utilizando sobrecarga de funciones y la verificaci√≥n
de propiedades con el operador `in`.

```typescript
interface Vehiculo {
  tipo: string;
  velocidadMaxima(): void;
}

interface Coche extends Vehiculo {
  tipo: "coche";
  marca: string;
}

interface Bicicleta extends Vehiculo {
  tipo: "bicicleta";
  tipoDeFreno: string;
}

function describirVehiculo(vehiculo: Coche): string;
function describirVehiculo(vehiculo: Bicicleta): boolean;

function describirVehiculo(vehiculo: Coche | Bicicleta): string | boolean {
  if ("marca" in vehiculo) {
    // El objeto es un coche
    console.log(`Es un coche de marca ${vehiculo.marca}`);
    vehiculo.velocidadMaxima();
    return vehiculo.marca;
  } else {
    // El objeto es una bicicleta
    console.log(`Es una bicicleta con freno de tipo ${vehiculo.tipoDeFreno}`);
    vehiculo.velocidadMaxima();
    return vehiculo.tipoDeFreno.length > 5;
  }
}

const miCoche: Coche = {
  tipo: "coche",
  marca: "Toyota",
  velocidadMaxima: () => console.log("200 km/h"),
};
const miBicicleta: Bicicleta = {
  tipo: "bicicleta",
  tipoDeFreno: "disco",
  velocidadMaxima: () => console.log("30 km/h"),
};

const resultadoCoche = describirVehiculo(miCoche); // Output: Es un coche de marca Toyota \n 200 km/h
const resultadoBicicleta = describirVehiculo(miBicicleta); // Output: Es una bicicleta con freno de tipo disco \n 30 km/h

console.log(resultadoCoche); // Output: Toyota
console.log(resultadoBicicleta); // Output: false
```

En este ejemplo, `describirVehiculo(miCoche)` devolver√° la marca del coche como
un `string`, mientras que `describirVehiculo(miBicicleta)` devolver√° un
`boolean` indicando si la longitud del tipo de freno de la bicicleta es mayor a
5 caracteres.

## Utilitarios de TypeScript: Helpers Esenciales

TypeScript ofrece una variedad de tipos utilitarios que facilitan la
manipulaci√≥n y gesti√≥n de tipos complejos. Estos helpers permiten transformar,
filtrar y crear nuevos tipos basados en otros tipos existentes. A continuaci√≥n,
exploraremos algunos de los helpers m√°s comunes y c√≥mo se pueden utilizar en el
desarrollo diario.

### Partial

`Partial<T>` convierte todas las propiedades de un tipo `T` en opcionales. Es
√∫til cuando queremos trabajar con versiones incompletas de un tipo.

```typescript
interface Usuario {
  nombre: string;
  edad: number;
  email: string;
}

const usuarioParcial: Partial<Usuario> = {
  nombre: "Juan",
};
```

### Required

`Required<T>` convierte todas las propiedades de un tipo `T` en requeridas. Es
el opuesto de `Partial`.

```typescript
interface Configuracion {
  modoOscuro?: boolean;
  notificaciones?: boolean;
}

const configuracionCompleta: Required<Configuracion> = {
  modoOscuro: true,
  notificaciones: true,
};
```

### Readonly

`Readonly<T>` convierte todas las propiedades de un tipo `T` en propiedades de
solo lectura.

```typescript
interface Libro {
  titulo: string;
  autor: string;
}

const libro: Readonly<Libro> = {
  titulo: "1984",
  autor: "George Orwell",
};

// libro.titulo = 'Rebeli√≥n en la granja'; // Error: no se puede asignar a 'titulo' porque es una propiedad de solo lectura.
```

### Record

`Record<K, T>` construye un tipo de objeto cuyas propiedades son claves del tipo
`K` y valores del tipo `T`.

```typescript
type Rol = "admin" | "usuario" | "invitado";

const permisos: Record<Rol, string[]> = {
  admin: ["leer", "escribir", "borrar"],
  usuario: ["leer", "escribir"],
  invitado: ["leer"],
};
```

### Pick

`Pick<T, K>` crea un tipo seleccionando un subconjunto de las propiedades `K` de
un tipo `T`.

```typescript
interface Persona {
  nombre: string;
  edad: number;
  direccion: string;
}

const personaNombreEdad: Pick<Persona, "nombre" | "edad"> = {
  nombre: "Mar√≠a",
  edad: 30,
};
```

### Omit

`Omit<T, K>` crea un tipo omitiendo un subconjunto de las propiedades `K` de un
tipo `T`.

```typescript
interface Producto {
  id: number;
  nombre: string;
  precio: number;
}

const productoSinId: Omit<Producto, "id"> = {
  nombre: "Laptop",
  precio: 1500,
};
```

### Exclude

`Exclude<T, U>` excluye de `T` los tipos que son asignables a `U`.

```typescript
type NumerosOString = string | number | boolean;

type SoloNumerosOString = Exclude<NumerosOString, boolean>; // string | number
```

### Extract

`Extract<T, U>` extrae de `T` los tipos que son asignables a `U`.

```typescript
type Tipos = string | number | boolean;

type SoloBooleanos = Extract<Tipos, boolean>; // boolean
```

### NonNullable

`NonNullable<T>` elimina `null` y `undefined` de un tipo `T`.

```typescript
type PosiblementeNulo = string | number | null | undefined;

type SinNulos = NonNullable<PosiblementeNulo>; // string | number
```

### ReturnType

`ReturnType<T>` obtiene el tipo de retorno de una funci√≥n `T`.

```typescript
function obtenerUsuario(id: number) {
  return { id, nombre: "Juan" };
}

type Usuario = ReturnType<typeof obtenerUsuario>; // { id: number, nombre: string }
```

### Ejemplo Completo

Vamos a ver un ejemplo pr√°ctico utilizando varios de estos helpers juntos:

```typescript
interface Usuario {
  id: number;
  nombre: string;
  email?: string;
  direccion?: string;
}

// Convertir todas las propiedades a opcionales
type UsuarioParcial = Partial<Usuario>;

// Convertir todas las propiedades a requeridas
type UsuarioRequerido = Required<Usuario>;

// Crear un tipo de solo lectura
type UsuarioSoloLectura = Readonly<Usuario>;

// Seleccionar solo algunas propiedades
type UsuarioBasico = Pick<Usuario, "id" | "nombre">;

// Omitir algunas propiedades
type UsuarioSinId = Omit<Usuario, "id">;

// Crear un registro de roles a permisos
type Rol = "admin" | "editor" | "lector";
const permisos: Record<Rol, string[]> = {
  admin: ["crear", "leer", "actualizar", "eliminar"],
  editor: ["crear", "leer", "actualizar"],
  lector: ["leer"],
};

// Excluir tipos
type ID = string | number | boolean;
type IDSinBooleanos = Exclude<ID, boolean>; // string | number

// Extraer tipos
type SoloBooleanos = Extract<ID, boolean>; // boolean

// Eliminar null y undefined
type PuedeSerNulo = string | null | undefined;
type NoNulo = NonNullable<PuedeSerNulo>; // string
```

## Generics en TypeScript

Los gen√©ricos en TypeScript son una poderosa herramienta que permite crear
componentes reutilizables y altamente flexibles. Los gen√©ricos proporcionan una
forma de definir tipos de una manera que a√∫n no est√° determinada, lo que permite
que las funciones, clases y tipos trabajen con cualquier tipo especificado en el
momento de la llamada o de la instanciaci√≥n. A continuaci√≥n, exploraremos los
conceptos b√°sicos y avanzados de los gen√©ricos en TypeScript, incluyendo
ejemplos pr√°cticos.

### Conceptos B√°sicos

Los gen√©ricos se declaran utilizando la notaci√≥n de √°ngulo `<T>`, donde `T` es
un par√°metro de tipo gen√©rico. Este par√°metro de tipo puede ser cualquier letra
o palabra, aunque `T` es com√∫nmente usado.

#### Funciones Gen√©ricas

Las funciones gen√©ricas permiten trabajar con cualquier tipo de dato sin
sacrificar la tipificaci√≥n.

```typescript
function identidad<T>(valor: T): T {
  return valor;
}

const numero = identidad<number>(42); // 42
const texto = identidad<string>("Hola Mundo"); // 'Hola Mundo'
```

#### Clases Gen√©ricas

Las clases gen√©ricas permiten crear estructuras de datos que pueden trabajar con
cualquier tipo.

```typescript
class Caja<T> {
  contenido: T;

  constructor(contenido: T) {
    this.contenido = contenido;
  }

  obtenerContenido(): T {
    return this.contenido;
  }
}

const cajaDeNumero = new Caja<number>(123);
console.log(cajaDeNumero.obtenerContenido()); // 123

const cajaDeTexto = new Caja<string>("Texto");
console.log(cajaDeTexto.obtenerContenido()); // 'Texto'
```

#### Interfaces Gen√©ricas

Las interfaces gen√©ricas permiten definir contratos que pueden adaptarse a
diferentes tipos.

```typescript
interface Par<K, V> {
  clave: K;
  valor: V;
}

const parNumeroTexto: Par<number, string> = { clave: 1, valor: "Uno" };
const parTextoBooleano: Par<string, boolean> = { clave: "activo", valor: true };
```

## Uso Avanzado de Gen√©ricos

### Restricciones en Gen√©ricos

Podemos restringir los tipos que un gen√©rico puede aceptar usando `extends`.

```typescript
interface ConNombre {
  nombre: string;
}

function saludar<T extends ConNombre>(obj: T): void {
  console.log(`Hola, ${obj.nombre}`);
}

saludar({ nombre: "Juan" }); // Hola, Juan
// saludar({ apellido: 'Perez' }); // Error: el objeto no tiene la propiedad 'nombre'
```

### Gen√©ricos en Funciones de Orden Superior

Podemos utilizar gen√©ricos en funciones que aceptan y retornan otras funciones.

```typescript
function procesar<T>(elementos: T[], callback: (elemento: T) => void): void {
  elementos.forEach(callback);
}

procesar<number>([1, 2, 3], (numero) => console.log(numero * 2)); // 2, 4, 6
```

## Ejemplo Completo con Tipos Complejos y `in`

A continuaci√≥n, vamos a combinar lo aprendido sobre gen√©ricos con una
comprobaci√≥n avanzada de tipos utilizando la palabra clave `in`.

```typescript
interface Animal {
  tipo: string;
  sonido(): void;
}

interface Gato extends Animal {
  tipo: "gato";
  raza: string;
}

interface Perro extends Animal {
  tipo: "perro";
  color: string;
}

function procesarAnimal<T extends Animal>(animal: T): string {
  if ("raza" in animal) {
    return `Es un gato de raza ${animal.raza}`;
  } else if ("color" in animal) {
    return `Es un perro de color ${animal.color}`;
  } else {
    return `Es un animal de tipo desconocido`;
  }
}

const miGato: Gato = {
  tipo: "gato",
  raza: "Siam√©s",
  sonido: () => console.log("Miau"),
};
const miPerro: Perro = {
  tipo: "perro",
  color: "Negro",
  sonido: () => console.log("Guau"),
};

console.log(procesarAnimal(miGato)); // Output: Es un gato de raza Siam√©s
console.log(procesarAnimal(miPerro)); // Output: Es un perro de color Negro
```

En este ejemplo, `procesarAnimal` es una funci√≥n gen√©rica que puede procesar
cualquier tipo de animal que extienda de `Animal`. Utilizamos la palabra clave
`in` para verificar la existencia de una propiedad y as√≠ determinar el tipo
exacto del objeto.

## La Magia de los Enums

Primero, definimos dos enums. Los enums son esos amigos que siempre traen algo
√∫til a la fiesta. Nos permiten agrupar constantes con nombre para que no
tengamos que andar adivinando qu√© significa cada valor.

```typescript
enum Numbers1 {
  "NUMBER1" = "number1",
  "NUMBER2" = "number2",
}

enum Numbers2 {
  "NUMBER3" = "number3",
}
```

## Combinando Superpoderes

Ahora, mezclamos estos dos enums en un solo objeto. Para esto, usamos el
operador de propagaci√≥n (`...`). Y ojo, porque `as const` es la clave ac√° para
que TypeScript trate este objeto como una constante inamovible.

```typescript
const myNumbers = { ...Numbers1, ...Numbers2 } as const;
const mixValues = Object.values(myNumbers);
```

## Tipos Derivados de los Enums Combinados

¬øY ahora qu√©? Bueno, ahora usamos `typeof` y `[number]` para crear un tipo que
represente los valores combinados de los enums. ¬øC√≥mo es esto?

```typescript
type MixNumbers = (typeof mixValues)[number];
```

### Pero, ¬øpor qu√© `[number]`?

Buena pregunta, querido lector. Cuando hacemos `Object.values(myNumbers)`,
obtenemos un array de valores. Entonces, `typeof mixValues` nos da el tipo de
este array, que es `string[]` en nuestro caso. Al usar `[number]`, estamos
diciendo "quiero el tipo de los elementos dentro de este array". Es como decirle
a TypeScript: ‚ÄúChe, dame el tipo de lo que hay adentro, no del contenedor‚Äù.

Ahora, la raz√≥n m√°s t√©cnica y precisa: los enums en TypeScript generan una
estructura interna que usa tanto las claves como los valores para crear una
especie de bi-direccionalidad. Esto significa que en el objeto enum, cada valor
tiene una clave num√©rica asociada autom√°ticamente. Cuando usamos `[number]`,
estamos aprovechando esta caracter√≠stica para obtener el tipo de los valores que
est√°n siendo indexados num√©ricamente.

## Creando un Tipo Basado en Nuestros Valores

Finalmente, creamos un tipo `Enums` que utiliza un √≠ndice mapeado para definir
propiedades basadas en los valores de `MixNumbers`. Cada propiedad puede ser de
cualquier tipo (`any`), porque a veces la vida es as√≠ de flexible.

```typescript
type Enums = {
  [key in MixNumbers]: any;
};
```

## El Ejemplo Completo

Vamos a ver el c√≥digo completo en acci√≥n:

```typescript
enum Numbers1 {
  "NUMBER1" = "number1",
  "NUMBER2" = "number2",
}

enum Numbers2 {
  "NUMBER3" = "number3",
}

const myNumbers = { ...Numbers1, ...Numbers2 } as const;
const mixValues = Object.values(myNumbers);

type MixNumbers = (typeof mixValues)[number];

type Enums = {
  [key in MixNumbers]: any;
};

// Ejemplo de uso
const example: Enums = {
  number1: "Este es el n√∫mero 1",
  number2: 42,
  number3: { detalle: "N√∫mero 3 como objeto" },
};

console.log(example);
```

## Desglose del C√≥digo

1. **Definici√≥n de Enums**: `Numbers1` y `Numbers2` son nuestros superh√©roes
   iniciales, cada uno con sus propios poderes.
2. **Combinaci√≥n de Enums**: Mezclamos los poderes de nuestros h√©roes en un solo
   equipo utilizando `...` y `as const`.
3. **Creaci√≥n de Tipos Derivados**: Utilizamos `typeof` y `[number]` para crear
   un tipo que representa los valores combinados.
4. **Definici√≥n del Tipo Enums**: Usamos un √≠ndice mapeado para definir
   propiedades basadas en `MixNumbers`.
