---
id: 'go_language'
order: 4
name: 'GoLang'
titleList:
  - name: 'How to Use GoLang'
    tagId: 'how-to-use-golang'
  - name: 'Advantages'
    tagId: 'advantages'
  - name: 'Recommended Structure'
    tagId: 'recommended-structure'
  - name: 'How Does GoLang Work?'
    tagId: 'how-does-golang-work'
  - name: 'Data Types'
    tagId: 'data-types'
  - name: 'Structs'
    tagId: 'structs'
  - name: 'Arrays'
    tagId: 'arrays'
  - name: 'Make Method'
    tagId: 'make-method'
  - name: 'Pointers'
    tagId: 'pointers'
  - name: 'Default Values'
    tagId: 'default-values'
  - name: 'Range Loop'
    tagId: 'range-loop'
  - name: 'Maps'
    tagId: 'maps'
  - name: 'Mutating Maps'
    tagId: 'mutating-maps'
  - name: 'Functions'
    tagId: 'functions'
  - name: 'Function Values'
    tagId: 'function-values'
  - name: 'Closures'
    tagId: 'closures'
  - name: 'Methods'
    tagId: 'methods'
  - name: 'Interfaces'
    tagId: 'interfaces'
  - name: 'Interface Values with Nil'
    tagId: 'interfaces'
  - name: 'Empty Interfaces'
    tagId: 'empty-interfaces'
---

# How to GoLang

An AMAZING language created by Google in collaboration with Rob Pike, Ken Thomson, and Robert Griesemer.

## Advantages:
- Fast, compiles directly into machine code without using an interpreter.
- Easy to learn, very good documentation, and many things are simplified.
- Scales very well, supports concurrent programming through "GoRoutines".
- Automatic garbage collector, automatic memory management.
- Included formatting engine, no need for third parties.
- No libraries required for testing or benchmarks because they are already included.
- Very little boilerplate for creating applications.
- Has an API for network programming, included as a standard library.
- VERY fast, in some benchmarks it is faster than backend applications made in Java and Rust.
- Built-in template system, GREAT for working with HTMX.

## Recommended Structure:
- **ui** (frontend-related content in case of server-side rendering)
  - *html* (templates)
  - *static* (multimedia and style static content)
    - *assets*
    - *css*
- **internal** (content related to tools and reusable entities throughout the project)
  - *models*
  - *utils*
- **cmd**
  - *web* (contains the application logic)
    - *domain* (business logic)
    - *routes* (available routes)

## How Does GoLang Work?

GoLang uses a base file called go.mod, which will contain the main module that will be called the same as the project, and also the version of Go used. Then each file will have the extension ".go" to identify that it is a package belonging to the language.

But... what is a package? 
If you come from JavaScript you can think of it in the same way as an ES module since it is used to encapsulate related logic. But unlike ES modules, the package is identified by the lines of code "package packageName" in camel case the name of the package in question and it imports the location of the package. Different files containing logic belonging to the same package can be arranged separately BUT they must be under the same parent folder as this is of utmost importance to later import said package in different ones.

To import a different package is done through the word "import" plus the path to which the package belongs.

```go
import "miProject/cmd/web/routes"
```

If you need more than one package at a time, it is not necessary to repeat the line of code since it can be grouped using "()" the various packages:

```go
import (
    "miProject/cmd/web/routes"
    "miProject/internal/models"
)
```

It is worth mentioning that then Go will relate the final name of the path with the use of the package so in order to use logic contained in it will be done thinking of it as if it were an object, where each property represents a logical element of the package:

```go
routes.MyRoute
```

Private and public package methods:

If the method starts with lowercase it is a private method, it cannot be accessed from outside the package itself.

```go
func myFunction()
```

If the method starts with uppercase it is a public method, it can be accessed by importing the package from another.

```go
func MyFunction()
```

Package scope

Let's see a Go file

```go
package main - package name

import "fmt" - fmt package is imported, no path because it's Go's own

var number int = 2

func main() {
    i, j := 42, 2701 - local variables to the method, i with value 42 and j with value 2701

    fmt.Println(i) - using the "Println" method of the "fmt" package
}
```

You surely have noticed something, "number" has a type "int" preceding the value assignment, while "i" and "j" do not, this is because like Typescript, Go infers the type for those primitives. Let's see how to work with types.

## Data Types

- **bool** = true / false
- **string** = string of characters
- **int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr** = integer numeric values with their limits, these are generally 32 bits on 32-bit systems and 64 for 64-bit systems. Integer should be used unless there is a specific reason to use a restricted value.
- **byte** === uint8
- **rune** === int32 
- **float32, float64** = represents real numeric values 
- **complex64, complex128** = complex numbers that have a real part and an imaginary part.

## Structs

Represents a collection of properties, you can think of it as a Typescript interface, as it represents the contract that must be followed when creating a property. Important, if you want that property to be accessible outside the package, remember it should start with "uppercase".

```go
type Person struct {
    Name string
    LastName string
    Age int
}

var person = Person {
    Name: "Gentleman",
    LastName: "Programming",
    Age: 31
}

fmt.Println(person.Name)
```

Another way:

```go
var persona2 = Persona{"Gentleman", "Programming", 31}
```

## Arrays

Now the fun begins, arrays are quite different from what we are used to as they MUST have the maximum number of elements they are going to contain inside:

```go
var a [10]int - creates an array of 10 elements of type int

a[0] = "Gentleman"
```

Or also

```go
var a = [2]int{2, 3}

fmt.Println(a) - [2 3]
```

If we need it to be dynamic we can talk about "slices".
A "slice" is a portion of an existing array or a representation of a collection of elements of a certain type.

```go
var primes = [6]int{2 ,3 ,5, 7, 11, 13}
var s []int = primes[1:4] - creates a slice using "primes" as a base from position 1 to 4

fmt.Println(s) - [3 5 7] 

s = append(s , 14)

fmt.Println(s) - [3 5 7 14] 

fmt.Println(primes) - [2 3 5 7 14 13]
```

You can also omit values ​​for maximum and minimum ranges making them have default values:

```go
var a [10]int

is the same as

a[0:10]
a[:10]
a[0:]
a[:]
```

## Make Method

To create dynamic slices you can use the included "make" method, this will create an array filled with empty elements and return a slice referring to it. The "len" method can be used to see how many elements it currently contains and "cap" to see its capacity, that is, how many elements it can hold.

```go
a := make([]int, 0, 5)  // len(a)=0 cap(a)=5
```

## Pointers

If you come from Javascript...

 this will take a bit, but let's see together the following example:

```go
type ElementType struct {
    name string 
}

var exampleElement = ElementType {
    name: "Gentleman",
} 

func MyFunction(element ElementType) {
    ...
}

MyFunction(exampleElement)
```
```markdown
Here you might think that we are working on the element "exampleElement", but it's quite the opposite. By default, Go will create a copy of the element itself to work with it, so the usage of "element" inside the function "MyFunction" is different from "exampleElement"... it's a copy.

So if we want to work with the same element passed as a parameter to the function, a pointer must be used. Normally when we create a variable, we mistakenly say that we create a property that holds a value inside it, when in reality what we are doing is creating a memory space, containing a value inside it, and then creating a reference (pointer) to that memory space which is represented by the name we give to our property:

```go
var a = 1
```

It creates a memory space which inside it contains the value "1" and we create a reference to that memory space called "a". The difference with Javascript is that this reference is not passed to the method unless we have created a pointer to it!

```go
var p *int // pointer "p" that will reference a property of type "int"

i := 42
p = &i // create a direct pointer to the property "i"

// If we want to access the value referenced by the pointer "p", we use the pointer's name preceded by the "*" symbol
fmt.Println(*p) // 42

*p = 21

fmt.Println(*p) // 21
```

Where this changes is if we point to a "struct", as it would be a bit cumbersome to do (*p).Property, it reduces to using it as if it were the struct itself:

```go
v := Person{"Gentleman"}
p := &v
p.Name = "Programming"
fmt.Println(v) // {Programming}
```

## Default Values

In Go, when you declare a variable without explicitly assigning a value, it takes on a default value based on its type. Here's a table summarizing the defaults:

**Default Values for Data Types:**

- **bool**: `false`
- **string**: `""` (empty string)
- **Numeric Types**: `0`
- **array**: `nil` (uninitialized)
- **map**: `nil` (uninitialized)
- **slice**: `nil` (uninitialized)
- **pointer**: `nil` (uninitialized)
- **function**: `nil` (uninitialized)

## Range Loop

The `range` loop is a powerful construct for iterating over sequences like slices, arrays, maps, and strings. It provides two components: the index (`i`) and the value (`v`) of each element. Here are three common variations:

* **Full Iteration:**

```go
var arr = []int{5, 4, 3, 2, 1}

for i, v := range arr {
  fmt.Printf("index: %d, value: %d\n", i, v)
}
```

This approach iterates over both the index and value of each element in `arr`.

* **Ignoring Index:**

```go
for _, v := range arr {
  fmt.Printf("value: %d\n", v)
}
```

The underscore (`_`) discards the index information, focusing only on the element values.

* **Ignoring Value:**

```go
for i, _ := range arr {
  fmt.Printf("index: %d\n", i)
}
```

Similarly, you can use an underscore to skip the value and access only the indices.

## Maps

Maps are unordered collections that associate unique keys (of any hashable type) with values. Go provides two ways to create and work with maps:

1. **Using `make` Function:**

   ```go
   type Persona struct {
     DNI, Nombre string
   }

   var m map[string]Persona

   func main() {
     m = make(map[string]Persona)
     m["123"] = Persona{"123", "pepe"}
     fmt.Println(m["123"])
   }
   ```

2. **Map Literal:**

   ```go
   type Persona struct {
     DNI, Nombre string
   }

   var m = map[string]Persona{
     "123": Persona{"123", "pepe"},
     "124": Persona{"124", "jorge"},
   }

   func main() {
     fmt.Println(m)
   }
   ```

   Map literals offer a concise way to initialize maps with key-value pairs.

## Mutating Maps

* **Insertion:**

   ```go
   m[key] = element
   ```

   Adds a new key-value pair to the map `m`.

* **Retrieval:**

   ```go
   element = m[key
   ```

## Functions

Functions are reusable blocks of code that perform specific tasks. They are declared with the `func` keyword, followed by the function name, parameter list (if any), return type (if any), and the function body enclosed in curly braces.

Here's an example:

```go
func greet(name string) string {
  return "Hello, " + name + "!"
}

func main() {
  message := greet("Golang")
  fmt.Println(message)
}
```

## Function Values

Functions can be assigned to variables, allowing you to pass them around like any other value. This enables powerful techniques like higher-order functions.

Here's an example demonstrating how to pass a function as an argument and call it indirectly:

```go
func CallCallback(callBack func(float64, float64) float64) float64 {
  return callBack(3, 4)
}

func hypot(x, y float64) float64 {
  return math.Sqrt(x*x + y*y)
}

func main() {
  fmt.Println(hypot(5, 12))
  fmt.Println(CallCallback(hypot))
}
```

## Closures

Closures are a special type of function that captures variables from its enclosing environment. This allows the closure to access and manipulate these variables even after the enclosing function has returned.

Here's an example of a closure that creates an "adder" function with a persistent sum:

```go
func adder() func(int) int {
  sum := 0

  return func(x int) int {
    sum += x
    return sum
  }
}

func main() {
  pos, neg := adder(), adder()

  for i := 0; i < 10; i++ {
    fmt.Println(
      pos(i),
      neg(-2*i),
    )
  }
}
```

## Methods

Go doesn't have classes, but it allows defining methods on types (structs, interfaces). A method is a function associated with a type, taking a receiver argument (usually the type itself) that implicitly refers to the object the method is called on.

Here's an example of a `Persona` struct with a `Saludar` method:

```go
type Persona struct {
  Nombre, Apellido string
}

func (p Persona) Saludar() string {
  return "Hola " + p.Nombre
}

func main() {
  p := Persona{"Pepe", "Perez"}
  fmt.Println(p.Saludar())
}
```

Methods can also be defined on non-struct types:

```go
type Nombre string

func (n Nombre) Saludar() string {
  return "Hola " + string(n)
}

func main() {
  nombre := Nombre("Pepe")
  fmt.Println(nombre.Saludar())
}
```

Methods can accept pointers as receivers, enabling modifications to the original object:

```go
type Persona struct {
  nombre, apellido string
}

func (p *Persona) cambiarNombre(n string) {
  p.nombre = n
}

func main() {
  p := Persona{"pepe", "perez"}
  p.cambiarNombre("juan")
  fmt.Println(p) // Output: {juan perez}

  pp := &Persona{"puntero", "persona"}
  pp.cambiarNombre("punteroNuevoNombre")
  fmt.Println(*pp) // Output: {punteroNuevoNombre persona}
}
```

Go automatically dereferences pointer receivers when necessary, so you don't always need to use the explicit `*` operator.

## Interfaces

Interfaces define a set of methods that a type must implement. They provide a way to achieve polymorphism, allowing different types to be used interchangeably as long as they implement the required methods.

Here's an example of an `Interface` that defines two methods, `Saludar` and `Moverse`:

```go
type Persona interface {
  Saludar() string
  Moverse() string
}

type Alumno struct {
  Nombre string
}

func (a Alumno) Saludar() string {
  return "Hola " + a.Nombre
}

func (a Alumno) Moverse() string {
  return "Estoy caminando"
}

func main() {
  var persona Persona = Alumno{
    "Pepe",
  }

  fmt.Println(persona.Saludar())
  fmt.Println(persona.Moverse())
}
```

## Interface Values with Nil

Interface values can be `nil`, indicating that they don't hold a reference to any specific object. Here's an example demonstrating how to handle `nil` interface values:

```go
type I interface {
  M()
}

type T struct {
  S string
}

func (t *T) M() {
  if t == nil {
    fmt.Println("<nil>")
    return
  }
  fmt.Println(t.S)
}

func main() {
  var i I

  var t *T
  i = t
  describe(i)
  i.M() // Output: <nil>

  i = &T{"hello"}
  describe(i)
  i.M() // Output: hello
}

func describe(i I) {
  fmt.Printf("(%v, %T)\n", i, i)
}
```

## Empty Interfaces

If you don't know the specific methods an interface might require beforehand, you can create an empty interface using the `interface{}` type. This allows you to store any value in the interface, but you won't be able to call methods on it directly.

```go
var i interface{}
```
