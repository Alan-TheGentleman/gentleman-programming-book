---
id: 'front-end-history'
order: 14
name: 'FrontEnd History'
titleList:
  - name: 'History of Front-End Development: from 1990 to the Future'
    tagId: 'history-of-front-end-development-from-1990-to-the-future'
  - name: 'The 90s Beginnings: The Awakening of the Static Web'
    tagId: 'the-90s-beginnings-the-awakening-of-the-static-web'
  - name: 'The 2000s: The Era of Interactivity and the Rise of Web 2.0'
    tagId: 'the-2000s-the-era-of-interactivity-and-the-rise-of-web-20'
  - name: '2010–2015: The Arrival of Frameworks and SPAs'
    tagId: '20102015-the-arrival-of-frameworks-and-spas'
  - name: '2016–2020: Consolidation and New Frontiers'
    tagId: '20162020-consolidation-and-new-frontiers'
  - name: '2021 Onward: The Present and Possible Future of Front-End'
    tagId: '2021-onward-the-present-and-possible-future-of-front-end'
---

# History of Front-End Development: from 1990 to the Future

The history of **front-end development** is a fascinating journey that spans  
several decades, from the simple text pages of the early 90s to today's complex  
web applications. Along the way, key technologies emerged to solve new challenges,  
influential **frameworks** were born and competed, and development practices were  
adopted (and later discarded), making the web more accessible and standardized. In  
this tale, we explore each stage of this evolution, like the story of a living being  
that grows, learns from its mistakes, and transforms relentlessly.

## The 90s Beginnings: The Awakening of the Static Web

Our story begins in the early 90s, when the web was young and static. In 1989,  
**Tim Berners-Lee** invented HTML (HyperText Markup Language), laying the  
foundation of the web ([Evolution of Web Development Technologies -  
Armadillo Amarillo](https://www.armadilloamarillo.com/blog/evolucion-de-las-tecnologias-de-desarrollo-web/#:~:text=Nacimiento%20del%20desarrollo%20web%3A%20Llegada,del%20HTML%20en%20los%2090)).  
The first web pages were essentially text documents with **hyperlinks**. There were  
no sophisticated styles or interactivity: content was shown linearly, with  
underlined links and plain text ([Evolution of Web Development Technologies -  
Armadillo Amarillo](https://www.armadilloamarillo.com/blog/evolucion-de-las-tecnologias-de-desarrollo-web/#:~:text=en%20que%20interactuamos%20con%20la,informaci%C3%B3n%20en%20l%C3%ADnea)). A famous  
site that still retains this style is the original _Space Jam_ page (1996), with a  
starry background, animated GIFs, and simple text—a window to the past that  
reminds us how the web looked in its infancy.

Soon, support for **images** arrived. In 1993, the NCSA Mosaic browser made  
history as the first to display inline images integrated with text  
([NCSA Mosaic - Wikipedia](https://en.wikipedia.org/wiki/NCSA_Mosaic#:~:text=NCSA%20Mosaic%20was%20among%20the,6)).  
This brought new visual appeal and excited designers, although 28.8 kbps modem  
connections imposed severe limits ([The Future of Frontend Technologies and its  
Impact on Conversion: WebAssembly - Flat 101](https://www.flat101.es/blog/desarrollo/el-futuro-de-las-tecnologias-frontend-y-su-impacto-en-la-conversion-webassembly/#:~:text=Nuestra%20historia%20empieza%20a%20principio,empezaban%20a%20incluir%20formularios%20complejos)).  
Bandwidth was scarce, so each image had to be used with great care. The historical  
context was a network mainly academic and governmental that was opening to the public,  
where publishing online required technical know-how.

**Key technologies**: In this early era, **HTML** in very basic versions reigned  
(with only a few tags) ([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=The%20first%20HTML%20specification%20was%C2%A0made,proposed%20by%C2%A0H%C3%A5kon%20Wium%20Lie%C2%A0in%C2%A0October%201994)).  
Pioneering browsers were Mosaic, then **Netscape Navigator** (1994) and Microsoft  
**Internet Explorer** (1995). By the mid-90s, the concept of **CSS** (Cascading  
Style Sheets) was introduced to handle presentation separately. CSS1 was published as  
a W3C recommendation in 1996, providing the first standard mechanism to separate style  
and content ([Introduction to CSS - A Brief History of CSS](https://www.technologyuk.net/website-development/introduction-to-css/introduction.shtml#:~:text=Within%20little%20over%20a%20year,code%20that%20defined%20its%20content)).  
However, initially almost no one used it since browsers took years to implement it  
correctly, and many devs still embedded styles directly in HTML  
([Introduction to CSS - A Brief History of CSS](https://www.technologyuk.net/website-development/introduction-to-css/introduction.shtml#:~:text=Unfortunately%2C%20it%20would%20be%20over,1)).  
Also, in 1995, **JavaScript** (initially called _Mocha_, then _LiveScript_) was  
created in just 10 days by Brendan Eich at Netscape  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=In%201995%2C%20a%20new%20browser,Ecma%20International%C2%A0is%20currently%20responsible%20for)).  
JavaScript was born to execute logic in the browser and add basic interactivity,  
although its use was limited in the 90s.

**Common practices**: Creating a web page in the 90s meant hand-writing HTML,  
structuring content with tags like `<h1>` and `<p>`. Initially there was no style;  
all pages inherited the browser's default look (gray or white background, black text,  
blue or violet links). When design needs emerged, developers used ingenious (and  
sometimes contrived) approaches. A popular trick was to use **HTML tables** to lay out  
invisible rows and columns, simulating a grid. Although tables were meant for data,  
they were nested to achieve complex multi-column designs  
([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=And%20all%20this%20time%2C%20tables,grids%20inside%20of%20other%20grids)).  
They also used presentational tags like `<font>` (introduced by Netscape in 1995) to  
change colors and fonts, or `<b>` and `<i>` for formatting. There were even oddities  
like `<blink>` (from Netscape) and `<marquee>` (from IE). These were experimental times  
amid the "**browser wars**"  
([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=The%20late%20%E2%80%9990s%20were%20a,best%20practice%20or%20dependable%20standard)).

Another practice was to split the window into **frames** using `<frame>`/`<frameset>`,  
which allowed, for example, a fixed menu in one frame and content in another. Though useful  
for navigation, frames complicated bookmarks and confused screen readers.

**Bad practices and consequences**: The abuse of tables and frames soon proved to be a  
**bad practice**. It produced heavy, hard-to-maintain pages by mixing structure and  
presentation, affecting performance  
([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=This%20came%20with%20some%20pretty,engines%20had%20the%20same%20problem)).  
Worse, **accessibility** was compromised, as assistive tools read those pages as endless  
empty tables, making navigation nearly impossible for people with disabilities  
([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=This%20came%20with%20some%20pretty,engines%20had%20the%20same%20problem)).  
Also, search engines found disorganized content, complicating early SEO. By the late  
90s, the W3C began to warn against these practices. The proliferation of presentational  
tags like `<font>` spurred the creation of CSS to separate presentation from content  
([Introduction to CSS - A Brief History of CSS](https://www.technologyuk.net/website-development/introduction-to-css/introduction.shtml#:~:text=Cascading%20style%20sheets%20,its%20underlying%20structure%20and%20meaning)).  
In parallel, in 1997 the **Web Standards Project (WaSP)** was formed to pressure browser  
makers to adhere to standards and eliminate hacks. Meanwhile, many sites showed  
"Best viewed in Netscape" or "Best viewed in IE."

Towards the late 90s, there was also an overuse of **annoying interactive  
elements**: pop-ups and excessive GIFs to make the web seem "alive." Personal pages with  
blinking text and MIDI background music were common. Although creative, these practices  
overloaded the experience and created chaos, leading users to install pop-up blockers,  
and developers learned that “less is more.”

**Historical context**: In 1996, with basic tools and no clear guidelines, if you needed  
a two-column layout you had to use nested tables  
([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=And%20all%20this%20time%2C%20tables,grids%20inside%20of%20other%20grids)).  
If you needed a fixed menu, frames were Netscape’s solution. It was an era of  
**making it up as you went along**. Moreover, intense browser competition pushed new  
features: Netscape and IE released versions at a frantic pace, each with proprietary  
tags, before standards existed  
([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=The%20late%20%E2%80%9990s%20were%20a,best%20practice%20or%20dependable%20standard)).  
For example, IE implemented CSS even before it was official  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=About%202%20years%20later%2C%20HTML,become%20a%C2%A0World%20Wide%20Web%20Consortium%C2%A0recommendation)),  
albeit in its own way (with notorious box model bugs). Netscape created its own script  
layer (Layers), speeding up evolution but leaving **incompatibilities**: what looked  
good in one browser broke in another  
([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=The%20late%20%E2%80%9990s%20were%20a,best%20practice%20or%20dependable%20standard)).  
The W3C tried to impose order with HTML3.2 (1997) and HTML4.0 (1999), later  
incorporating de facto extensions.

By the late 90s, the foundations of **web accessibility** were also laid. In 1997, the  
W3C’s Web Accessibility Initiative (WAI) was formed, and in 1999 WCAG 1.0 was published,  
with 14 accessibility guidelines  
([WCAG Version History | Accessible Web](https://accessibleweb.com/wcag/wcag-version-history/#:~:text=In%20May%201999%2C%20the%20Web,making%20AAA%20the%20most%20comprehensive)).  
However, outside institutional circles, few paid attention; the priority was that the  
site “worked and looked good.” It would take years for this to become truly important.

**Development tools**: In the beginning, there was no sophisticated front-end  
ecosystem. The most used IDE was **Notepad**. Many wrote HTML in simple text editors,  
saved the file, and reloaded the browser to see the result. Tools like HoTMetaL and  
Adobe PageMill (mid-90s) offered semi-visual editors; Microsoft released **FrontPage**  
(1997), a WYSIWYG that generated HTML automatically; and Macromedia introduced  
**Dreamweaver** (1998), popular among designers. These tools made site creation easier  
for non-programmers, but produced "tag soup." For **debugging**, the 90s mostly used  
JavaScript alerts and manual code review. Later, source code viewers appeared, but the  
environment was very artisanal.

Despite its limitations, this early stage laid the foundation for front-end. HTML  
evolved from just text to supporting images and forms; CSS emerged timidly; and  
JavaScript sparked interactivity. The web was mainly **“read-only”**  
([Link | The Evolution of Frontend Development: A Look at its History and Current State  
at Link Money](https://link.money/blog/the-evolution-of-frontend-development#:~:text=,1995)), that is, a medium to  
**consume** static information. But the stage was set for the next act: with the new  
millennium, greater interactivity and dynamism were demanded, and front-end was ready  
to evolve at full speed.

## The 2000s: The Era of Interactivity and the Rise of Web 2.0

With the turn of the millennium, the web entered a phase of transformation. In the  
**2000s**, static pages were no longer enough: users wanted more  
**interactivity** and companies saw the web as an application platform. The term  
**Web 2.0** emerged to describe the new participatory web, where users not only read  
content but also created it (blogs, forums, nascent social networks). To support this vision,  
front-end had to mature rapidly, adopting new technologies and practices.

**Key technologies**: In the early 2000s, the three pillars of modern front-end were  
consolidated: **HTML**, **CSS**, and **JavaScript**  
([Evolution of Web Development Technologies - Armadillo Amarillo](https://www.armadilloamarillo.com/blog/evolucion-de-las-tecnologias-de-desarrollo-web/#:~:text=Como%20hemos%20vito%2C%20el%20HTML,a%20principios%20de%20los%202000)).  
HTML4 (recommended since 1999) became the de facto standard, with richer elements  
(lists, tables, robust forms) and “transitional” and “strict” versions to move away  
from outdated presentational tags. **CSS2** (1998) began to be widely used by mid-decade:  
browsers supported it better and the community embraced the separation of style and  
content. For example, **Internet Explorer 6** (2001) supported CSS (with infamous bugs)  
and **Firefox** (2004) championed standards. Projects like the **Acid2 Test** (2005)  
exposed IE’s defects and forced Microsoft to improve  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=A%20group%20known%20as%20the%C2%A0Web,the%20following%20image%20should%20appear)).

The true star of the 2000s was **real-time interactivity**. Here, **JavaScript**  
shone, particularly with the **AJAX** (Asynchronous JavaScript and XML) technique. Although  
the ability to make asynchronous requests without a full page refresh existed since IE5  
(1999), it did not catch on until mid-decade  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=Image)).  
Everything changed in 2004–2005 with revolutionary Google applications like **Gmail**  
and **Google Maps**, which demonstrated AJAX’s power: Gmail offered instantly updating  
mail, and Google Maps allowed smooth dragging of the map  
([What Does AJAX Even Stand For? - The History of the Web](https://thehistoryoftheweb.com/what-does-ajax-even-stand-for/#:~:text=Google%20released%20Gmail%20to%20the,it%20felt%20like%20a%20desktop))  
([What Does AJAX Even Stand For? - The History of the Web](https://thehistoryoftheweb.com/what-does-ajax-even-stand-for/#:~:text=Both%20Gmail%20and%20Google%20Maps,thank%20for%20that%20particular%20feature)).  
For the first time, a web application could **feel like a desktop app**, without  
reloading the entire page on every click. In 2005, Jesse James Garrett coined the term  
“AJAX” to describe this combo (JS + XMLHttpRequest + XML/JSON + HTML/CSS), and it quickly  
became a buzzword. AJAX made interactive Web 2.0 possible.

As JavaScript grew more complex, the first **JavaScript libraries and frameworks**  
emerged to ease developers’ lives. In the mid-2000s, libraries like **Prototype** and  
**MooTools** appeared, but the one that conquered all was **jQuery** (2006). Created by  
John Resig, jQuery simplified DOM manipulation and event handling by wrapping common  
operations in simple functions and abstracting cross-browser differences  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=Image))  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=was%C2%A0jQuery,to%20make%20any%20website%20interactive)).  
Its slogan, “Write Less, Do More,” summed up its benefit: instead of handling different  
methods, you could simply do `$("#myElement").hide()`. By 2008, jQuery was essential in  
any front-end project, marking the start of the **front-end frameworks** era.

In **CSS**, the first **CSS frameworks** emerged to speed up design. Projects like  
Blueprint CSS (2007) or 960.gs offered **grid systems** and utility classes, avoiding the  
reinvention of the wheel  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=Around%20the%20mid,earliest%20CSS%20frameworks%20included%C2%A0Blueprint%2C%C2%A0960%2C%C2%A0YUI%20Grids%C2%A0and%C2%A0YAML))  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=When%20mobile%20phones%20manufacturers%20began,fit%20into%20the%20small%20screens)).  
This laid the foundation for later frameworks like Bootstrap.

We cannot forget **Adobe Flash**. Flash (originally from Macromedia, bought by Adobe  
in 2005) was not part of the standard stack, but it was ubiquitous in the 2000s to do what  
HTML+CSS+JS could not yet. With Flash, rich experiences were delivered: animations, web  
games, video players (YouTube in 2005 used Flash), and fully interactive sites. Flash had  
its peak in the early 2000s  
([HTML5 vs. FLASH: The End of an Era and a New Dawn | Coconut©](https://www.coconut.co/articles/html5-vs-flash-the-end-of-an-era-and-a-new-dawn#:~:text=Flash%27s%20Dominance%20in%20Early%202000s)).  
Many companies used **Flash intros**, but as a proprietary technology with performance  
and security issues, its use became problematic. It consumed a lot of CPU, often froze  
the browser, and did not work on emerging mobile devices  
([HTML5 vs. FLASH: The End of an Era and a New Dawn | Coconut©](https://www.coconut.co/articles/html5-vs-flash-the-end-of-an-era-and-a-new-dawn#:~:text=However%2C%20as%20we%20move%20forward%2C,the%20web%20moved%20towards%20open)).  
In 2007, Apple blocked Flash on the iPhone, marking its decline.

**Common practices**: In the early 2000s, front-end techniques became more  
professional. A common practice was to separate files: HTML for structure, external CSS  
for styles, and JavaScript for logic. Previously, CSS and JS were embedded in HTML, but  
separating them improved organization and caching. Likewise, web design abandoned table-  
based layouts in favor of **CSS layouts** (using divs, floats, etc.) between 2003 and 2005,  
consolidating the separation of content and presentation  
([Introduction to CSS - A Brief History of CSS](https://www.technologyuk.net/website-development/introduction-to-css/introduction.shtml#:~:text=already%20started%20work%20on%20CSS,code%20that%20defined%20its%20content)).

With Web 2.0, partial content refreshing via AJAX became popular. Previously, hidden  
iframes or other tricks were used, but then comments, results, etc. could load without a  
full page reload, which required handling asynchronous states in JavaScript and better  
server coordination.

Additionally, the **user-site collaboration** defined the era: users generated content.  
This led to integrating WYSIWYG editors (like CKEditor or TinyMCE), live validations, etc.,  
and increased the load on client-side JavaScript. At the same time, **CMS** (WordPress  
2003, Joomla 2005, Drupal 2001) became common, with front-end developers customizing themes  
using HTML/CSS/JS and creating reusable templates.

**Bad practices and consequences**: Between 2000 and 2010, several bad practices emerged.  
The most notorious was the persistence of **Internet Explorer 6** and its hacks. IE6 became  
the dominant browser after 2001, yet it did not fully adhere to standards. Many devs wrote  
code exclusive to IE6 (non-standard properties and methods) that broke in other browsers.  
Microsoft stopped updating IE6, and maintaining compatibility became a burden. CSS hacks  
for IE6 cluttered stylesheets and created technical debt  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=Supporting%20multiple%20browsers%20was%20a,various%20problems%20with%20specific%20browsers)).

Another bad practice was **overusing Flash**. Some sites were 100% Flash, with no HTML  
alternative, resulting in **zero accessibility** and poor SEO. Moreover, if the plugin was  
not updated, nothing would display. With the rise of mobile (iPhone without Flash), these  
sites became obsolete, forcing a major rework  
([HTML5 vs. FLASH: The End of an Era and a New Dawn | Coconut©](https://www.coconut.co/articles/html5-vs-flash-the-end-of-an-era-and-a-new-dawn#:~:text=However%2C%20as%20we%20move%20forward%2C,the%20web%20moved%20towards%20open)).

In JavaScript, **“spaghetti code”** was common—disorganized code with huge functions  
and global variables, making maintenance difficult and bugs frequent. This led to the need  
for structured frameworks in the next decade.

There was also an overuse of pop-ups and intrusive redirects, which annoyed users.  
The industry gradually learned to replace these with silent updates or well-designed  
AJAX requests.

Lessons were learned: adhering to standards pays off, accessibility and lightness are  
essential, and better tools were needed to handle large-scale JavaScript. This paved the  
way for the major leap in the next decade when structured frameworks and SPAs became  
the norm.

**Competition and influences**: In the 2000s, technological competition shaped  
front-end. The **browser wars** continued: after Netscape’s fall, IE dominated, but in  
2004 Firefox emerged as the standards champion, and in 2008 **Google Chrome** arrived with  
great speed. This forced Microsoft to respond with IE7/IE8, reducing the use of proprietary  
"dialects."

In the realm of **JS libraries**, Prototype, MooTools, Dojo, and YUI competed, but  
**jQuery** prevailed for its simplicity  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=Image))  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=was%C2%A0jQuery,to%20make%20any%20website%20interactive)).  
This unified development since in the 90s each browser had its own "dialect," and by  
the late 2000s most used jQuery to cover 90% of cases.

There was also competition among **CMS and tools**: WordPress vs. Joomla vs. Drupal, and  
Dreamweaver vs. manual editors, which spurred constant improvements.

**Development tools**: The 2000s brought crucial improvements. A milestone was  
**Firebug** (2006) for Firefox, the first extension to inspect HTML, CSS, and JS live  
([Firebug (software) - Wikipedia](<https://en.wikipedia.org/wiki/Firebug_(software)#:~:text=Firebug%20is%20a%20discontinued%20free,5>)).  
It allowed real-time style editing and JS debugging with breakpoints, ushering in the  
era of **Developer Tools**. Safari released Web Inspector in 2006, and Chrome DevTools was  
integrated in 2008  
([Chromium Blog: 10 Years of Chrome DevTools](https://blog.chromium.org/2018/09/10-years-of-chrome-devtools.html#:~:text=Like%20the%20Net%20panel%20of,tooling%20directly%20into%20the%20browser)).  
By 2009, developers had consoles, performance profilers, and more. Without these tools,  
the AJAX era would have been much clumsier.

In editors, more powerful IDEs like **Eclipse** and **NetBeans** emerged. Adobe released  
**Flash Builder** and Microsoft **Visual Studio Express** for web development. Many front-end  
devs preferred lightweight editors like **Notepad++** or **TextMate** (for Mac). By the end  
of the 2000s, **Sublime Text** (2008) arrived, fast and popular in the following decade.

Automated **testing tools** also emerged: **Selenium** (2004) for end-to-end tests and  
libraries like **QUnit** for unit tests, though these were still minor at the time.

By the close of the 2000s, front-end had evolved from the "little brother" of back-end  
to a field of rapid innovation, with more dynamic sites, better design patterns, and tools  
that made development more enjoyable. But the best was yet to come: the 2010s would see  
the explosion of structured frameworks, SPAs, and the definitive consolidation of front-end  
as a software engineering discipline.

## 2010–2015: The Arrival of Frameworks and SPAs

At the start of the **2010s**, front-end took a revolutionary leap. Web applications  
became more ambitious and complex, nearing desktop functionality. This demanded new  
architectural approaches in the browser. Between 2010 and 2015, the great JavaScript  
**frameworks** were born and consolidated, forever changing the way web apps are built.  
The era shifted from jQuery scripting to **Single Page Applications (SPA)** and  
component-based structured code.

**Key technologies**: In the early 2010s, HTML and CSS also evolved. In 2014 the W3C  
officially published **HTML5**, though since 2010 many browsers already supported parts  
of it (semantic tags like `<article>`, `<section>`, `<canvas>` for graphics, `<video>`,  
`<audio>`, local storage, etc.). HTML5 replaced capabilities that once required Flash  
or hacks. **CSS3** introduced rounded corners (border-radius), shadows (box-shadow),  
transitions, animations, 2D/3D transformations, and **media queries** for adaptive design,  
just as **smartphones** (iPhone 2007, Android 2008) became widespread. In 2010, Ethan  
Marcotte coined “Responsive Web Design,” which became the standard for sites that adapt  
to different screen sizes.

To facilitate responsive design, Twitter launched **Bootstrap** (2011) as an open  
source CSS framework, with a 12-column fluid grid and prebuilt components, adopting a  
**mobile-first** approach (from v2 in 2012)  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=In%202007%2C%20the%20first%20iPhone,their%20websites%20for%20mobile%20screens)).  
It was immediately popular, and by 2013/2014 it became the base for many projects.  
Foundation (by Zurb) was another alternative.

But the real revolution came from **JavaScript**. The jQuery approach (imperative and  
global) had limits in large applications. There was a need for better code organization,  
separation of responsibilities, reuse of UI components, and efficient state management.  
Inspired by backend MVC patterns, several JS **MVC/MVVM frameworks** emerged.

One of the first to stand out was **Backbone.js** (2010), with simple models, collections,  
and views  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=)).  
Almost simultaneously, **Knockout.js** (2010) appeared, focused on declarative **data binding**.  
**Ember.js** (2011, evolved from SproutCore) offered more structure, but the big milestone  
was **AngularJS**. Launched in 2009 by Miško Hevery and adopted by Google, AngularJS  
became popular between 2011 and 2012. It offered a complete MVC framework with  
**two-way data binding**, dependency injection, and routing for **SPAs**  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=AngularJS%C2%A0came%20into%20the%20market%20in%C2%A0October,routing%20package%20and%20much%20more)).  
For the first time, the entire logic of a single page could be built on the client, with  
the server serving only JSON data. AngularJS stood out by allowing HTML to be enriched  
with custom directives. By 2013, AngularJS was the favorite in many corporate settings,  
marking the **framework-centric** era.

**Common practices**: With these frameworks, **SPAs** became popular. Instead of many  
independent HTML pages, a SPA loads a single "shell" and handles client-side navigation  
with JavaScript, updating the view dynamically without a full reload. The HTML5 History API  
allows the URL to change without reloading. Developers began to think in terms of  
**components** or **templates** rendered on the client. For example, with AngularJS, the  
app was divided into controllers and partial views (HTML) for each section, and Angular  
swapped them based on the route, improving organization and **reuse**.

The **MVC/MVVM** architecture was also adopted: models for data, reactive views, and  
controllers to manage user input. This made the code more maintainable and testable, and  
unit testing in front-end began using tools like Jasmine/Karma, marking a cultural shift.

Between 2010 and 2015, the ecosystem of **build tools** flourished. Writing code was no  
longer enough: developers had to concatenate, **minify** JS/CSS, transpile, run linters,  
and manage dependencies. **Grunt** (2012) and later **Gulp** (2013) emerged. For handling  
front-end packages, Twitter created **Bower** (2012)  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=)),  
though soon **npm** became the hub, rendering Bower obsolete  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=In%202014%2C%20a%20central%20repository,was%20created%2C%20called%20the%C2%A0npm%20registry)).  
Thus, front-end devs adopted workflows similar to back-end: `npm install` and build scripts.

The trend for **preprocessors** also arose. In CSS, **Sass** (SCSS) and **LESS** allowed the use  
of variables, nesting, and mixins to compile into clean CSS. For JS, **CoffeeScript** (2009)  
offered a more concise syntax and inspired **TypeScript** (2012), a superset of JS with  
optional static typing for large projects. **Babel** (2014) also appeared to let developers use  
ES6 before browsers supported it, enabling modern code without long waits.

**Framework competition**: The early 2010s saw an explosion of JS frameworks. AngularJS  
got much attention, but it competed with Backbone (lighter) and Ember (more structured).  
Debates were intense: was Angular’s two-way binding better or was Backbone’s one-way flow  
preferable? In 2013, Facebook launched **React** at JSConf US. React, a view library with a  
**Virtual DOM**, initially sparked skepticism (JSX mixing HTML and JS, re-rendering the full  
virtual DOM), but it demonstrated performance and modularity advantages. React proposed a  
**unidirectional data flow**, contrary to AngularJS’s bidirectional binding, making it more  
predictable in large apps. When Facebook showed how React solved complex UI problems, many  
were convinced  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=called%C2%A0React%C2%A0was%20introduced,flow%20and%20the%20Flux%20pattern)).  
Thus began the Angular vs. React "war," and Google, after using AngularJS until 2016, rewrote  
it as **Angular 2** (2016) in TypeScript with a more reactive approach. Meanwhile, in 2014,  
Evan You created **Vue.js**, a lightweight library that took the best of AngularJS. Over time,  
Vue became known as "the third wheel," gaining popularity (especially in Asia) among devs  
seeking something simpler than Angular yet more structured than React. Vue 2 arrived in 2016  
with two-way binding and a Virtual DOM.

This **competition** was fierce but fruitful: Angular rewrote itself to be more modular;  
React optimized its DOM reconciliation and expanded its ecosystem (Redux, React Router, etc.);  
and Vue showed that excellent documentation and a gentle learning curve could attract many.  
By the late 2010s, **React** was the most popular globally  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=match%20at%20L324%20React,if%20you%20are%20using%20React)),  
with modern Angular and Vue as key alternatives. The use of **reusable components**, a  
**Virtual DOM** for efficiency, and front-end state management (Redux, Vuex, etc.) became  
standard, along with solutions like **React Native** (2015) for mobile and **Electron** (2013)  
for desktop.

**Tool evolution (2010–2015)**: As complexity grew, tools advanced further. More  
sophisticated build systems emerged, like **Webpack** (2012–2013), which enabled bundling,  
code splitting, and loaders for JS, CSS, and images, becoming a pillar for many SPAs. IDEs  
evolved: JetBrains released **WebStorm**, and the king became **Visual Studio Code** (2015),  
free with excellent TS/JS support and extensions, which won over the community.

Debugging became even easier: Chrome DevTools added performance panels, mobile network  
simulators, and render timelines, while Firefox revamped its tools. Extensions like  
**React DevTools** and **Vue DevTools** allowed inspection of component structure and state.

In **testing**, tools like **Mocha** (2011), **Chai**, and later **Jest** (2016, from Facebook)  
emerged for React, along with **Cypress.io** (2014, popular since 2017) for end-to-end tests.  
Linters like ESLint (2013) and formatters like Prettier (2017) became part of the workflow,  
professionalizing front-end.

**Accessibility and standardization**: In the early 2010s, web accessibility gained  
importance. **WCAG 2.0** (2008) was adopted, and many countries updated their laws.  
Frameworks like AngularJS encouraged using ARIA attributes, and Bootstrap included ARIA  
roles. In 2014, **WAI-ARIA 1.0** was published, and attention was given to focus, contrast,  
and alt attributes on images. Tools like **axe-core** (2015) automated accessibility checks.

Standardization advanced further: **ECMAScript 2015 (ES6)** was released in 2015 with  
classes, modules, arrow functions, and Promises. With Babel, frameworks adopted ES6 rapidly,  
and JS began having annual updates (ES2016, ES2017, etc.). Browsers adopted automatic  
updates (Chrome since 2008, Firefox and Edge in 2015), allowing new features without long waits.  
For example, **Flexbox** (CSS3) became widely used from 2013 once supported by most browsers.

By 2015, cross-browser compatibility was no longer the nightmare of old: IE had fallen  
out of favor (IE11 in 2013 still caused issues but was a minority compared to Chrome/Firefox).  
Microsoft released Edge (2015) in an attempt at a fresh start, later migrating to Chromium  
(2019). A major milestone was reached: most users now used browsers aligned with modern  
standards, freeing front-end from historical burdens.

The history of front-end in the first half of the 2010s was one of **professionalism and  
robustness**. It evolved from an improvised field to one building true client-side architectures.  
But evolution did not stop: in the latter half of the 2010s and into 2020, everything was  
further consolidated and new trends emerged, making front-end even more powerful.

## 2016–2020: Consolidation and New Frontiers

In the latter half of the 2010s, front-end reached great maturity. **Component-based  
frameworks** (React, Angular, Vue) became the standard for complex apps. At the same time,  
ideas and tools emerged that pushed limits—from running JavaScript on the server for initial  
rendering to using compiled languages in the browser. Let’s see how things evolved up to  
the present.

**Framework consolidation**: By 2016–2017, most new projects chose React, Angular, or Vue.  
**Angular** launched Version 2 in 2016 (simply called Angular), written in TypeScript and  
aimed at a more **enterprise** approach (clear MVC structure, official CLI, modules) with  
improved performance, though it broke compatibility with AngularJS. **React** continued to  
gain followers, with a growing ecosystem (Redux in 2015, UI libraries, Create React App  
in 2016). **Vue.js** matured with version 2 (2016) and grew unexpectedly, thanks to its ease  
and strong performance (even adopted by companies like Alibaba). By 2019, it was common for a  
front-end dev to master at least one of the three.

The **competition** stabilized: React became popular in global communities  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=match%20at%20L324%20React,if%20you%20are%20using%20React)),  
Angular remained strong in corporate environments, and Vue enjoyed a loyal community.  
They influenced each other: Angular added Ivy (2019) similar to React, React introduced  
Hooks (2019), and Vue 3 (2020) included a Composition API inspired by Hooks. They converged  
toward more **declarative and reusable components**, minimizing unpredictable shared state.

**Isomorphism and SSR**: **Server-Side Rendering (SSR)** combined with SPAs made a  
comeback to address SEO and initial load issues. Frameworks and methods emerged to render  
on the server and then “hydrate” on the client. **Next.js** (2016, on React) facilitated SSR,  
and similar tools appeared such as **Nuxt.js** for Vue and Angular Universal for Angular,  
giving prominence back to the server in **isomorphic** apps.

At the same time, **JAMstack** (JavaScript, APIs, pre-generated markup) gained strength.  
Tools like **Gatsby** (2017, React) or **Gridsome** (2018, Vue) allowed building full static  
sites that later behave like SPAs, offering high performance and security at the cost of  
more complex deployment.

**New languages and WebAssembly**: Efforts were made to bring compiled languages to the  
browser using **WebAssembly (WASM)**, a 2017 standard that defines a portable binary format  
to run low-level code at high speed  
([The Future of Frontend Technologies and its Impact on Conversion: WebAssembly -  
Flat 101](https://www.flat101.es/blog/desarrollo/el-futuro-de-las-tecnologias-frontend-y-su-impacto-en-la-conversion-webassembly/#:~:text=Cuando%20pensamos%20en%20rendimiento%20a,binario%20optimizado%20para%20un%20procesador)).  
This allows compiling C/C++/Rust to WASM for use on the web. Although its use was limited  
in 2018–2019, examples (3D games, image editors, heavy algorithms) showed JS alone was not  
always enough. The message: front-end is no longer restricted to JS; for critical parts,  
modules in **WebAssembly** can achieve near-native performance. For example, Figma uses WASM  
for desktop-like performance. Tools like DOSBox or Blazor illustrate a future with multiple  
languages in front-end.

In JavaScript, **TypeScript** moved from a curiosity to mainstream. Angular adopted it  
from the start, Microsoft pushed it, and the React community began using it massively  
around 2018–2019. Strong typing helped reduce errors in large projects.

**Common practices**: During these years, practices such as **global state  
architecture** in complex SPAs (using Redux, MobX, or Vuex) became standard to manage  
shared data without excessive prop drilling. There was also a focus on **perceived  
performance**: Google pushed Lighthouse (2015) and Core Web Vitals, and devs optimized  
load times, lazy loading, and code splitting. Mobile optimization and front-end  
**security** (using Content Security Policy to mitigate XSS) also became priorities.

**Tools and DevOps**: By 2020, a front-end dev had an integrated arsenal. **VS Code**  
dominated with extensions for each framework. Cloud services like **CodeSandbox** and  
**StackBlitz** emerged for rapid prototyping. CI/CD pipelines (via GitHub Actions, GitLab CI,  
etc.) and the rise of **design systems** (e.g., Material, Carbon, Lightning) documented with  
tools like Storybook (2016) further professionalized the workflow.

**Accessibility and standards**: By around 2018, accessibility was further integrated:  
**WCAG 2.1** was published, and legal pressures (e.g., Domino’s in 2019) enforced accessible  
websites. Front-end now sees accessibility as a **requirement** rather than a luxury.  
Standardization continued with WHATWG and W3C unifying the HTML specification as a  
"living standard" in 2019. New web APIs appeared: **Service Workers** (2016) for offline PWAs,  
**WebSockets** and **WebRTC** for real-time communication, and the **WebAssembly 1.0**  
specification (2019).

By the end of the 2010s, front-end was a vibrant universe: mature frameworks, professional  
tools, and a solid culture of standards and accessibility. But the story does not end here.

## 2021 Onward: The Present and Possible Future of Front-End

We have reached the **present** (2021–2025) and glimpse the near future. Today, front-end  
continues to evolve rapidly—perhaps more incrementally than before. The foundations (components,  
SPAs, performance, tooling) are being refined and new trends promise to take the web even  
further.

**Current state (2021–2025)**: A front-end dev is now expected to master **HTML5, CSS3,  
ESNext** and at least one popular framework (with React nearly ubiquitous in job listings)  
([History of Front-End Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=match%20at%20L324%20React,if%20you%20are%20using%20React)).  
Angular (v14–16) and Vue (v3 in 2020) remain strong. **Svelte**, created by Rich Harris  
(2016), has gained attention for its radical approach: instead of a runtime framework, it is  
a compiler that converts components into optimized JS with minimal overhead. Svelte 3  
(2019) is known as the **“disappearing framework.”** Although still a minority compared  
to React, Angular, and Vue, its philosophy has influenced the idea of compiling rather than  
loading a heavy framework at runtime.

Another trend is the rise of **meta-frameworks** and integrated tools. **Next.js** has  
consolidated as the de facto standard for commercial React projects (supporting SSG, SSR, and  
API routes) with backing from Vercel  
([Link | The Evolution of Frontend Development: A Look at its History and Current State  
at Link Money](https://link.money/blog/the-evolution-of-frontend-development#:~:text=CSS%2C%20and%20JavaScript%2C%20as%20well,need%20to%20keep%20up%20with)).  
In Vue, **Nuxt 3** (2022) offers a similar approach. New meta-frameworks like **Remix**  
(2021, for React) propose loading data from the server rather than relying solely on  
client-side APIs. And for less coupled apps, **Astro** (2021) renders only HTML by default  
and "hydrates" with JS only where needed, reducing the JS payload.

Also, **micro-frontends** have grown in large enterprises: breaking an app into independent  
front-end fragments (even using different frameworks) that are then assembled. Although  
complex, this approach scales like microservices on the back-end.

**Tool development**: Developer Experience (DX) continues to improve. In build tools,  
bundlers like **esbuild** (written in Go) and **Vite** (2020, from Evan You) have emerged,  
leveraging native ES Modules for great speed and simplicity. Vite has become popular in  
Vue, React, and Svelte, challenging Webpack. The trend is toward **speed and simplicity**.  
In editors, VS Code remains dominant, and GitHub has integrated **Copilot** (2021), an AI-  
powered code assistant that can complete entire functions from comments, hinting that AI  
will play an increasing role in daily development.

**Focus on performance and UX**: Users are ever more impatient. Google penalizes poor  
performance in SEO, and companies invest heavily in optimization. Concepts like  
**Edge Computing**—serving content from CDNs and cloud functions near the user—are gaining  
traction. Modern frameworks support this (Next.js middleware on Vercel, Cloudflare Workers, etc.),  
aiming for an **instant** experience. Concepts such as **ISR (Incremental Static  
Regeneration)**, which blends static and dynamic content by refreshing pages on the CDN,  
are emerging.

In **UX** and interactivity, augmented reality (AR) and virtual reality (VR) via WebXR  
are increasingly integrated. Although still niche, some sites now showcase 3D AR products  
via a mobile camera or deliver VR experiences in the browser. As device power grows and  
graphical APIs like **WebGPU** emerge, even more immersive experiences will be possible.

**Accessibility and ethics**: Accessibility continues to advance. **WCAG 2.2** was  
approved (2021, to be finalized in 2023/24) and work on WCAG 3.0 is underway. Many devs  
now know the **POUR** principles (Perceivable, Operable, Understandable, Robust)  
([WCAG Version History | Accessible Web](https://accessibleweb.com/wcag/wcag-version-history/#:~:text=Almost%20a%20decade%20later%2C%20in,addressing%20content%20implemented%20using%20HTML)).  
IDE tools now warn of accessibility errors in real time. There is also growing awareness  
of **privacy** (GDPR, cookie banners) and **sustainability** (energy-efficient web design).

**Possible future**: Where is front-end headed? One avenue is greater  
**modularity and interoperability**, perhaps via **Web Components** that allow sharing  
components regardless of the framework. With component-based architecture now common,  
the next step is composing full micro-applications seamlessly.

Artificial intelligence may generate more adaptive and intelligent interfaces,  
adjusting design and flow in real time based on user behavior (using, for example,  
TensorFlow.js). Imagine a site that changes its font size if it detects eye strain or  
reorders sections based on scrolling behavior. The line between design and development  
could blur further as AI generates styles on the fly.

Regarding language, **JavaScript** will likely remain ubiquitous, but with WebAssembly,  
we may see more languages coexisting (Rust or C++ for critical parts, JS/TS for the rest),  
or even exploring compiling JS to WASM in some cases.

Front-end is also expanding into other environments: **smart TVs**, IoT devices with  
web screens, car dashboards, etc. Due to the web's ubiquity, it may become the universal  
operating system for interfaces, so standardization will need to consider more device types  
and interaction methods.

Finally, the culture of **open source and collaboration** will continue to drive  
evolution. Much of the tooling and even frameworks (React, Vue, Svelte) are open source,  
allowing rapid iteration and mass adoption. The front-end community shares knowledge in blogs,  
conferences, and on GitHub, so any new idea will be widely disseminated and improved.

**Conclusion**: The history of front-end development, from 1990 to today, is one of  
staggering growth: from text documents to rich apps; from `<font>` and tables to advanced  
CSS and flexible layouts; from small scripts to complete client-side architectures. Each stage,  
with new demands (more users, devices, and interactivity), spurred the invention of new  
technologies and practices. There were setbacks—bad practices like overusing tables or Flash—  
but the community corrected its course. Competition among browsers and frameworks sometimes  
fragmented the field, but ultimately raised the overall level, providing us with powerful  
browsers and incredible development tools.

Today, front-end is an exciting field where design and programming converge, and a  
developer must consider both user experience (accessibility) and code performance. In the  
future, the line between front-end and other areas will blur: front-end touches the server  
(with isomorphic rendering), mobile (PWAs, React Native), design (design systems), and even  
machine learning. Perhaps in a few years we will speak not of “front-end” but simply of  
**web development**, as the client/server divide becomes less rigid.

One thing is certain: the web will keep **surprising us**, and front-end development  
will be at the forefront of that constant innovation. In just over thirty years, we went from  
text pages to global interactive experiences. The next thirty years will bring innovations  
we can barely imagine—and new challenges that will require the creativity and passion of the  
front-end community to keep writing this never-ending story  
([Evolution of Web Development Technologies - Armadillo Amarillo](https://www.armadilloamarillo.com/blog/evolucion-de-las-tecnologias-de-desarrollo-web/#:~:text=La%20accesibilidad%20web%20para%20todas,continuar%C3%A1%20siendo%20un%20viaje%20emocionante)).

**References:**

- Rubio, M. (2024). _Evolución de las tecnologías de desarrollo web_. Armadillo  
  Amarillo  
  ([Evolution of Web Development Technologies - Armadillo Amarillo](https://www.armadilloamarillo.com/blog/evolucion-de-las-tecnologias-de-desarrollo-web/#:~:text=Nacimiento%20del%20desarrollo%20web%3A%20Llegada,del%20HTML%20en%20los%2090))  
  ([Evolution of Web Development Technologies - Armadillo Amarillo](https://www.armadilloamarillo.com/blog/evolucion-de-las-tecnologias-de-desarrollo-web/#:~:text=En%20sus%20primeras%20versiones%2C%20solo,subrayados%20y%20texto%20sin%20estilizar)).
- James, S. (2023). _The Evolution of Frontend Development_. Link Money  
  ([Link | The Evolution of Frontend Development: A Look at its History and Current  
  State at Link Money](https://link.money/blog/the-evolution-of-frontend-development#:~:text=,1995))  
  ([Link | The Evolution of Frontend Development: A Look at its History and Current  
  State at Link Money](https://link.money/blog/the-evolution-of-frontend-development#:~:text=responsibilities,need%20to%20keep%20up%20with)).
- _The History of the Web_. **Tables for Layout? Absurd.** (2018)  
  ([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=The%20late%20%E2%80%9990s%20were%20a,best%20practice%20or%20dependable%20standard))  
  ([Tables for Layout? Absurd. - The History of the Web](https://thehistoryoftheweb.com/tables-layout-absurd/#:~:text=This%20came%20with%20some%20pretty,engines%20had%20the%20same%20problem)).
- Flat 101 (2020). _El futuro de las tecnologías frontend y su impacto..._  
  ([The Future of Frontend Technologies and its Impact on Conversion: WebAssembly -  
  Flat 101](https://www.flat101.es/blog/desarrollo/el-futuro-de-las-tecnologias-frontend-y-su-impacto-en-la-conversion-webassembly/#:~:text=Con%20una%20navegaci%C3%B3n%20tan%20lenta%2C,interacci%C3%B3n%20con%20estas%20aplicaciones%20pesadas))  
  ([The Future of Frontend Technologies and its Impact on Conversion: WebAssembly -  
  Flat 101](https://www.flat101.es/blog/desarrollo/el-futuro-de-las-tecnologias-frontend-y-su-impacto-en-la-conversion-webassembly/#:~:text=Durante%20los%202000%2C%20se%20fueron,hasta%20el%20d%C3%ADa%20de%20hoy)).
- Wanyoike, M. (2019). _History of Front-End Frameworks_. LogRocket  
  ([History of Frontend Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=During%20the%20early%20years%20of,total%20mess%20in%20another%20browser))  
  ([History of Frontend Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=A%20group%20known%20as%20the%C2%A0Web,the%20following%20image%20should%20appear)).
- Wanyoike, M. (2019). _History of Front-End Frameworks_ (CSS frameworks). LogRocket  
  ([History of Frontend Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=Around%20the%20mid,earliest%20CSS%20frameworks%20included%C2%A0Blueprint%2C%C2%A0960%2C%C2%A0YUI%20Grids%C2%A0and%C2%A0YAML))  
  ([History of Frontend Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=In%202007%2C%20the%20first%20iPhone,their%20websites%20for%20mobile%20screens)).
- Wanyoike, M. (2019). (JavaScript evolution). LogRocket  
  ([History of Frontend Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=Image))  
  ([History of Frontend Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=AngularJS%C2%A0came%20into%20the%20market%20in%C2%A0October,routing%20package%20and%20much%20more)).
- LogRocket Blog (2019). _React, Angular, Vue..._  
  ([History of Frontend Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=called%C2%A0React%C2%A0was%20introduced,flow%20and%20the%20Flux%20pattern))  
  ([History of Frontend Frameworks - LogRocket Blog](https://blog.logrocket.com/history-of-frontend-frameworks/#:~:text=match%20at%20L336%20He%20previously,maintained%20by%20the%20Vue%20team)).
- Mozilla Developer Network. **Firebug**. Wikipedia  
  ([Firebug (software) - Wikipedia](<https://en.wikipedia.org/wiki/Firebug_(software)#:~:text=Firebug%20is%20a%20discontinued%20free,5>))  
  ([Firebug (software) - Wikipedia](<https://en.wikipedia.org/wiki/Firebug_(software)#:~:text=Firebug%20was%20licensed%20under%20the,9>)).
- Chromium Blog (2018). _10 Years of Chrome DevTools_  
  ([Chromium Blog: 10 Years of Chrome DevTools](https://blog.chromium.org/2018/09/10-years-of-chrome-devtools.html#:~:text=Like%20the%20Net%20panel%20of,tooling%20directly%20into%20the%20browser))  
  ([Chromium Blog: 10 Years of Chrome DevTools](https://blog.chromium.org/2018/09/10-years-of-chrome-devtools.html#:~:text=)).
- Coconut (2021). _HTML5 vs. FLASH: The End of an Era and a New Dawn_  
  ([HTML5 vs. FLASH: The End of an Era and a New Dawn | Coconut©](https://www.coconut.co/articles/html5-vs-flash-the-end-of-an-era-and-a-new-dawn#:~:text=Flash%27s%20Dominance%20in%20Early%202000s))  
  ([HTML5 vs. FLASH: The End of an Era and a New Dawn | Coconut©](https://www.coconut.co/articles/html5-vs-flash-the-end-of-an-era-and-a-new-dawn#:~:text=However%2C%20as%20we%20move%20forward%2C,the%20web%20moved%20towards%20open)).
- Accessible Web (2020). _WCAG Version History_  
  ([WCAG Version History | Accessible Web](https://accessibleweb.com/wcag/wcag-version-history/#:~:text=In%20May%201999%2C%20the%20Web,making%20AAA%20the%20most%20comprehensive))  
  ([WCAG Version History | Accessible Web](https://accessibleweb.com/wcag/wcag-version-history/#:~:text=Almost%20a%20decade%20later%2C%20in,addressing%20content%20implemented%20using%20HTML)).
